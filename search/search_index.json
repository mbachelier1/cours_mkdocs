{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Ce site est destin\u00e9 aux \u00e9l\u00e8ves de NSI1 et NSI2 du lyc\u00e9e Rabelais de Saint Brieuc. Les visiteurs sont bienvenus et peuvent me contacter s'ils le souhaitent.","title":"Accueil"},{"location":"nsi1/index.html","text":"NSI1 - Informations \u2693\ufe0e 30/05/2021 : Ajout du chapitre 20 05/05/2021 : Ajout du chapitre 19 03/05/2021 : Ajout du chapitre 18 26/04/2021 : Ajout de l'activit\u00e9 \u00ab Initiation au shell linux \u00bb","title":"Infos"},{"location":"nsi1/index.html#nsi1-informations","text":"30/05/2021 : Ajout du chapitre 20 05/05/2021 : Ajout du chapitre 19 03/05/2021 : Ajout du chapitre 18 26/04/2021 : Ajout de l'activit\u00e9 \u00ab Initiation au shell linux \u00bb","title":"NSI1 - Informations"},{"location":"nsi1/ch18/reseaux.html","text":"R\u00e9seau - principes \u2693\ufe0e Un r\u00e9seau , c'est un ensemble d' entit\u00e9s qui communiquent : des fourmis qui envoient des informations par voie chimique (les ph\u00e9romones); des individus qui s'envoient des colis postaux ou du courrier; des ordinateurs qui s'envoient des donn\u00e9es. Chacun des trois exemples ci-dessus est remarquable par son efficacit\u00e9. Le premier est sans doute le fruit de l'\u00e9volution. Le deuxi\u00e8me est le r\u00e9sultat de conventions et processus que les \u00eatres humains ont produits : parmi ces conventions il y a les r\u00e8gles d'\u00e9criture d'une adresse postale et aussi le moyen de payer le transport du colis via un ou des timbres postaux et parmi les processus il y a l'acheminement du courrier par voie routi\u00e8re, ferr\u00e9e, maritime ou a\u00e9rienne. Quant au troisi\u00e8me, il est \u00e9galement le fruit de conventions et processus tr\u00e8s aboutis que nous allons tenter de d\u00e9tailler dans ce chapitre, il fonctionne remarquablement bien et s'appelle Internet. Ce r\u00e9seau, compos\u00e9 de milliards de machines qui communiquent entre elles et qui permet \u00e0 deux ordinateurs s\u00e9par\u00e9s de milliers de kilom\u00e8tres de s'\u00e9changer une quantit\u00e9 consid\u00e9rable d'informations en une fraction de seconde est bel et bien la plus grande structure que l'\u00eatre humain ait construit \u00e0 ce jour. Elle m\u00e9rite bien qu'on s'attarde un peu sur son fonctionnement. L'id\u00e9e du mod\u00e8le \u00e0 couches empil\u00e9es \u2693\ufe0e La finalit\u00e9 d'un r\u00e9seau, quel qu'il soit, c'est transporter de la mani\u00e8re la plus fiable possible des informations (ou des biens), lesquelles sont \u00e9mises par une entit\u00e9 A, \u00e0 destination d'une entit\u00e9 B, et seront transmises en passant tr\u00e8s probablement par des entit\u00e9s interm\u00e9diaires. Le processus peut \u00eatre variable mais il existe des m\u00e9canismes communs \u00e0 la plupart des moyens de communication : on cherche \u00e0 d\u00e9composer en \u00e9tapes et les similitudes apparaissent : A poss\u00e8de une information \u00ab brute \u00bb; l'information est \u00ab conditionn\u00e9e \u00bb pour \u00eatre envoy\u00e9e; il existe un moyen fiable de savoir comment faire arriver l'information en B; en d\u00e9finitive, la transmission s'effectue par un moyen physique; du point de vue de B, les choses s'effectuent \u00ab \u00e0 l'envers \u00bb : par moyen physique, A a r\u00e9ussi \u00e0 lui faire parvenir une information \u00ab conditionn\u00e9e \u00bb que B traite pour finalement disposer de l'information brute de A. L'exemple du r\u00e9seau postal \u2693\ufe0e Les consid\u00e9rations pr\u00e9c\u00e9dentes sont tr\u00e8s abstraites, nous allons donc envisager l'exemple d'une personne A qui souhaite envoyer un cadeau \u00e0 B. L'information est le cadeau en lui m\u00eame, le r\u00e9seau est le r\u00e9seau postal : On a d\u00e9compos\u00e9 la communication en 5 couches, auxquelles on a donn\u00e9 des noms qui sont d\u00e9j\u00e0 li\u00e9s au vocabulaire des r\u00e9seaux informatiques . En voici le d\u00e9tail dans l'ordre chronologique: Communication Du point de vue de A Couche 5 - Application : A veut envoyer un cadeau \u00e0 B; Couche 4 - Transport : le cadeau est emball\u00e9 pour pouvoir \u00eatre transport\u00e9 et re\u00e7u intact. On y met aussi l'adresse postale de B; Couche 3 - R\u00e9seau : le bureau de poste d\u00e9termine comment acheminer le colis : il a d\u00e9j\u00e0 l'adresse postale de B mais il trouve par lui-m\u00eame la route qu'il fera suivre au colis; Couche 2 - Lien : La route est trouv\u00e9e mais il faut d\u00e9terminer comment transporter ce colis : si c'est par voie routi\u00e8re on doit savoir quels v\u00e9hicules capables d'acheminer le cadeau sont disponibles maintenant ou bien quels sont ceux qui le seront tr\u00e8s prochainement; Couche 1 - Physique : c'est le transport effectif du colis. Du point de vue de B Couche 1 - Physique : c'est \u00e9galement le transport effectif du colis; Couche 2 - Lien : le colis arrive au bureau postal; Couche 3 - R\u00e9seau : le bureau de poste d\u00e9termine comment acheminer le colis chez B; Couche 4 - Transport : le cadeau est arriv\u00e9 chez B qui le d\u00e9balle; Couche 5 - Application : B profite de son cadeau. L'int\u00e9r\u00eat de la d\u00e9composition en couches est qu'elle s\u00e9pare un probl\u00e8me complexe en une succession de t\u00e2ches plus simples. Chaque couche n'interagit directement qu'avec ses couches voisines (ce sont les fl\u00e8ches en trait plein) de mani\u00e8re relativement simple . L'interaction de chaque couche chez A avec la couche de m\u00eame niveau chez B est cependant plus complexe (ce sont les fl\u00e8ches en pointill\u00e9s). Couche 1 A - Couche 1 B : c'est le trajet du v\u00e9hicule qui transporte le cadeau; Couche 2 A - Couche 2 B : c'est la planification du trajet; Couche 3 A - Couche 3 B : c'est l'envoi du cadeau au niveau postal; Couche 4 A - Couche 4 B : c'est la phase emballage/d\u00e9ballage; Couche 5 A - Couche 5 B : c'est l'envoi du cadeau de A \u00e0 B. En g\u00e9n\u00e9ral un colis postal est d'un seul tenant mais on peut tr\u00e8s bien imaginer que le cadeau que A veut envoyer \u00e0 B soit tr\u00e8s volumineux (par exemple la collection des romans \u00ab Les Rougon-Macquart \u00bb d'Emile Zola qui comporte 20 livres qui se suivent). Lors de la phase d'emballage, plusieurs \u00abpaquets \u00bb sont cr\u00e9\u00e9s et envoy\u00e9s s\u00e9par\u00e9ment. B ne les re\u00e7oit pas obligatoirement dans l'ordre d'envoi mais ce n'est pas grave car il finit par avoir tous les paquets et remet les romans dans le bon ordre. Un mod\u00e8le informatique : TCP/IP \u2693\ufe0e Un ordinateur A veut envoyer des donn\u00e9es \u00e0 un ordinateur B. On supposera que ces donn\u00e9es sont un fichier . Le processus ressemble \u00e0 l'exemple pr\u00e9c\u00e9dent. On va pr\u00e9senter le mod\u00e8le le plus courant dont le nom est TCP/IP et qu'on peut \u00e9galement mod\u00e9liser avec 5 couches empil\u00e9es. On appelle protocole tout programme utilis\u00e9 par une couche. Du point de vue de l'\u00e9metteur \u2693\ufe0e Ce qu'il faut retenir c'est que lors de la transmission tr\u00e8s t\u00f4t dans le processus, le fichier est d\u00e9coup\u00e9 en paquets; chaque couche (hormis la couche application) ajoute son propre en-t\u00eate aux donn\u00e9es re\u00e7ues par la couche sup\u00e9rieure et destin\u00e9 \u00e0 la m\u00eame couche pour le destinataire. Ce proc\u00e9d\u00e9 s'appelle encapsulation . Couche 5 - Application Cette couche est charg\u00e9e d'envoyer les donn\u00e9es d'un programme sur l'ordinateur A \u00e0 un programme sur l'ordinateur B. Puisque plusieurs programmes peuvent utiliser la couche transport en m\u00eame temps, il existe 65536 ports et chaque application va utiliser un ou plusieurs ports particuliers. Les num\u00e9ros de ports sont attribu\u00e9s par convention mais il est possible de les changer. Les protocoles les plus connus sont HTTP ( HyperText Transfer Prococol ), protocole de transfert hypertexte, sur le port 80 ou 443 pour sa version s\u00e9curis\u00e9e HTTPS; FTP ( File Transfer Protocol ), protocole de transfert de fichiers, sur les ports 20 et 21, et 990 pour sa version s\u00e9curis\u00e9e FTPS; SMTP ( Simple Mal Transfer Protocol ), charg\u00e9 d'envoyer les emails et POP3 ( Post Office Protocol ) de les r\u00e9cup\u00e9rer; DNS ( Domain Name System ), charg\u00e9 de traduire un nom de site en adresse IP; BitTorrent, charg\u00e9 de r\u00e9cup\u00e9rer et diffuser des fichiers. Couche 4 - Transport Cette couche va d\u00e9couper les donn\u00e9es fournie par la couche 5 en paquets (d'une taille de l'ordre du kilooctet). Elle ajoute \u00e9galement son propre en-t\u00eate \u00e0 chaque paquet. Les protocoles les plus connus sont TCP ( Transfert Control Protocol ), protocole de contr\u00f4le des transmissions, qui est fiable, fonctionne sur le principe d'une connexion avec accus\u00e9 de r\u00e9ception. UDP ( User Datagram Protocol ), non fiable en th\u00e9orie, sans connexion ni accus\u00e9 de r\u00e9ception, mais plus rapide. On utilise TCP lorsque les donn\u00e9es \u00e0 recevoir sont sensibles (t\u00e9l\u00e9chargement d'un fichier). UDP sera pr\u00e9f\u00e9r\u00e9 dans le cas du streaming : le protocole est plus rapide et permet par exemple de visionner un film avec une bonne qualit\u00e9, et si des donn\u00e9es sont perdues, ce n'est pas grave, on passe aux donn\u00e9es suivantes, cela ne perturbe pas trop le film (on ne va pas, comme ce serait le cas pour TCP, attendre que les donn\u00e9es soient arriv\u00e9es, et faire des pauses). Couche 3 - R\u00e9seau Cette couche est responsable de l'aiguillage des paquets vers l'adresse de destination. Elle encapsule les paquets de la couche 4 et y ajoute son propre en-t\u00eate (en g\u00e9n\u00e9ral un en-t\u00eate IP). Du point de vue de cette couche, les paquets sont \u00e0 envoyer \u00e0 un ordinateur muni d'une adresse IP (nombre attribu\u00e9 par ce protocole). Pour que les paquets trouvent leur chemin de l'ordinateur A \u00e0 l'ordinateur B (qui peut \u00eatre \u00e0 plusieurs milliers de kilom\u00e8tres de A), de protocoles de routage sont utilis\u00e9s , les machines d\u00e9di\u00e9es au routage s'appellent des routeurs . Un routeur n'utilise que les couches 1,2 et 3 du mod\u00e8le. Il faut retenir que chaque paquet suit son propre chemin, ind\u00e9pendamment des autres et qu'il a un \u00abtemps de vie\u00bb (pour \u00e9viter, s'il est perdu, de circuler sur le r\u00e9seau pendant des ann\u00e9es). Parmi les protocoles utilis\u00e9s par cette couche on trouve IP ( Internet Protocol ), d\u00e9crit ci-dessus; ARP ( Address Resolution Protocol ) qui permet de trouver l'adresse physique de l'ordinateur connect\u00e9 \u00e0 l'adresse IP. Ce protocole est utilis\u00e9 lorsque l'information est arriv\u00e9e \u00e0 B et \u00abremonte les couches \u00bb. Couche 2 - Lien Elle est charg\u00e9e de coordonner le transfert des donn\u00e9es ainsi que le \u00abtemps de parole \u00bb de chaque machine connect\u00e9e au support physique (si toutes les machines connect\u00e9es \u00e0 un m\u00eame support \u00e9mettent des donn\u00e9es en m\u00eame temps, il risque d'y avoir des collisions ). Elle encapsule les paquets de la couche sup\u00e9rieure dans ce qu'on appelle des trames (trames Ethernet par exemple). Du point de vue de la couche lien, la destination d'un paquet est une adresse physique appel\u00e9e adresse MAC ( Media Access Control ), d\u00e9termin\u00e9e par la carte r\u00e9seau de la machine destinataire. Les protocoles utilis\u00e9s par cette couche sont Ethernet (r\u00e9seau filaire), Wi-Fi (r\u00e9seau via les ondes radios) et Bluetooth (ondes radio \u00e9galement). Couche 1 - Physique Elle est charg\u00e9e de la transmission effective des trames (qu'elle encapsule \u00e9galement) d'un bout \u00e0 l'autre du support physique. Du point de vue du r\u00e9cepteur \u2693\ufe0e `` Il faut retenir que chaque couche d\u00e9paqu\u00e8te le paquet (ou trame) qui lui est adress\u00e9 en enlevant l'en-t\u00eate correspondant et passe le relais \u00e0 la couche du dessus. Le mat\u00e9riel \u2693\ufe0e Couche physique \u2693\ufe0e Liaison filiaire Les informations peuvent \u00eatre transmises via des c\u00e2bles. Le plus utilis\u00e9 est le c\u00e2ble Ethernet. Son nom est UTP-CAT5 ou UTP-CAT6, la diff\u00e9rence \u00e9tant que le second permet un d\u00e9bit dix fois plus grand que le premier ( 1 Gbit/s contre 100 Mbit/s). Parmi les autres types de liaisons filaires, on compte la liaison par c\u00e2ble t\u00e9l\u00e9phonique (qui permet par exemple de se connecter \u00e0 Internet par ADSL) et la liaison par c\u00e2ble optique. Bluetooth C'est une technologie utilisant les ondes radios pour permettre la communication entre les \u00e9quipements \u00e9lectroniques (imprimantes, t\u00e9l\u00e9phones, scanners, syst\u00e8me audio portatif ou dans un v\u00e9hicule...) \u00e0 courte distance. Ses fonctionnalit\u00e9s sont assez limit\u00e9es en terme de mise en r\u00e9seau. Wi-Fi Cette technologie utilise \u00e9galement les ondes radio. Son nom de norme est IEEE 802.11 et c'est le moyen de transmission des donn\u00e9es sans fil le plus utilis\u00e9. R\u00e9p\u00e9teur Lorsqu'un signal parcourt le support physique, son intensit\u00e9 s'att\u00e9nue avec la distance. Un r\u00e9p\u00e9teur r\u00e9g\u00e9n\u00e8re le signal per\u00e7u avec plus d'intensit\u00e9 pour pallier ce probl\u00e8me. Concentrateur Le concentrateur ( hub ) est moins utilis\u00e9 de nos jours. C'est une version \u00ab multiprise \u00bb du r\u00e9p\u00e9teur : quand il re\u00e7oit un signal sur un des ses branchements, il les recopie sur tous les autres branchements sans se soucier de l'\u00e9ventuel destinataire du signal. Carte r\u00e9seau Que ce soit une cl\u00e9 USB Wi-Fi ou une carte r\u00e9seau interne, c'est la m\u00eame chose : ce composant est indispensable pour connecter un ordinateur \u00e0 un r\u00e9seau. Chaque carte r\u00e9seau poss\u00e8de une adresse MAC : c'est l'adresse physique de la carte, elle permet d'identifier l'ordinateur de mani\u00e8re unique. Couche lien \u2693\ufe0e Commutateur Le commutateur ( switch en Anglais) est un \u00e9quipement \u00e0 plusieurs branchements (au moins 2) appel\u00e9s ports (ne pas confondre avec la notion de port utilis\u00e9 par une application). Son r\u00f4le est de rediriger une trame re\u00e7ue vers l'ordinateur de destination. Couche r\u00e9seau \u2693\ufe0e Routeur Le routeur ( router en Anglais) permet d'effectuer le routage des paquets et de les faire transiter d'une partie du r\u00e9seau vers une autre (par exemple d'un r\u00e9seau local \u00e0 un autre, nous verrons cela plus tard). Couches sup\u00e9rieures \u2693\ufe0e C'est un ordinateur qui ex\u00e9cute les protocoles des couches transport et application. Cela peut \u00eatre un t\u00e9l\u00e9phone, une tablette, un ordinateur portable ou de bureau ou bien encore un objet connect\u00e9 tel qu'une enceinte Bluetooth.","title":"CH18 : R\u00e9seaux - principes"},{"location":"nsi1/ch18/reseaux.html#reseau-principes","text":"Un r\u00e9seau , c'est un ensemble d' entit\u00e9s qui communiquent : des fourmis qui envoient des informations par voie chimique (les ph\u00e9romones); des individus qui s'envoient des colis postaux ou du courrier; des ordinateurs qui s'envoient des donn\u00e9es. Chacun des trois exemples ci-dessus est remarquable par son efficacit\u00e9. Le premier est sans doute le fruit de l'\u00e9volution. Le deuxi\u00e8me est le r\u00e9sultat de conventions et processus que les \u00eatres humains ont produits : parmi ces conventions il y a les r\u00e8gles d'\u00e9criture d'une adresse postale et aussi le moyen de payer le transport du colis via un ou des timbres postaux et parmi les processus il y a l'acheminement du courrier par voie routi\u00e8re, ferr\u00e9e, maritime ou a\u00e9rienne. Quant au troisi\u00e8me, il est \u00e9galement le fruit de conventions et processus tr\u00e8s aboutis que nous allons tenter de d\u00e9tailler dans ce chapitre, il fonctionne remarquablement bien et s'appelle Internet. Ce r\u00e9seau, compos\u00e9 de milliards de machines qui communiquent entre elles et qui permet \u00e0 deux ordinateurs s\u00e9par\u00e9s de milliers de kilom\u00e8tres de s'\u00e9changer une quantit\u00e9 consid\u00e9rable d'informations en une fraction de seconde est bel et bien la plus grande structure que l'\u00eatre humain ait construit \u00e0 ce jour. Elle m\u00e9rite bien qu'on s'attarde un peu sur son fonctionnement.","title":"R\u00e9seau - principes"},{"location":"nsi1/ch18/reseaux.html#lidee-du-modele-a-couches-empilees","text":"La finalit\u00e9 d'un r\u00e9seau, quel qu'il soit, c'est transporter de la mani\u00e8re la plus fiable possible des informations (ou des biens), lesquelles sont \u00e9mises par une entit\u00e9 A, \u00e0 destination d'une entit\u00e9 B, et seront transmises en passant tr\u00e8s probablement par des entit\u00e9s interm\u00e9diaires. Le processus peut \u00eatre variable mais il existe des m\u00e9canismes communs \u00e0 la plupart des moyens de communication : on cherche \u00e0 d\u00e9composer en \u00e9tapes et les similitudes apparaissent : A poss\u00e8de une information \u00ab brute \u00bb; l'information est \u00ab conditionn\u00e9e \u00bb pour \u00eatre envoy\u00e9e; il existe un moyen fiable de savoir comment faire arriver l'information en B; en d\u00e9finitive, la transmission s'effectue par un moyen physique; du point de vue de B, les choses s'effectuent \u00ab \u00e0 l'envers \u00bb : par moyen physique, A a r\u00e9ussi \u00e0 lui faire parvenir une information \u00ab conditionn\u00e9e \u00bb que B traite pour finalement disposer de l'information brute de A.","title":"L'id\u00e9e du mod\u00e8le \u00e0 couches empil\u00e9es"},{"location":"nsi1/ch18/reseaux.html#lexemple-du-reseau-postal","text":"Les consid\u00e9rations pr\u00e9c\u00e9dentes sont tr\u00e8s abstraites, nous allons donc envisager l'exemple d'une personne A qui souhaite envoyer un cadeau \u00e0 B. L'information est le cadeau en lui m\u00eame, le r\u00e9seau est le r\u00e9seau postal : On a d\u00e9compos\u00e9 la communication en 5 couches, auxquelles on a donn\u00e9 des noms qui sont d\u00e9j\u00e0 li\u00e9s au vocabulaire des r\u00e9seaux informatiques . En voici le d\u00e9tail dans l'ordre chronologique: Communication Du point de vue de A Couche 5 - Application : A veut envoyer un cadeau \u00e0 B; Couche 4 - Transport : le cadeau est emball\u00e9 pour pouvoir \u00eatre transport\u00e9 et re\u00e7u intact. On y met aussi l'adresse postale de B; Couche 3 - R\u00e9seau : le bureau de poste d\u00e9termine comment acheminer le colis : il a d\u00e9j\u00e0 l'adresse postale de B mais il trouve par lui-m\u00eame la route qu'il fera suivre au colis; Couche 2 - Lien : La route est trouv\u00e9e mais il faut d\u00e9terminer comment transporter ce colis : si c'est par voie routi\u00e8re on doit savoir quels v\u00e9hicules capables d'acheminer le cadeau sont disponibles maintenant ou bien quels sont ceux qui le seront tr\u00e8s prochainement; Couche 1 - Physique : c'est le transport effectif du colis. Du point de vue de B Couche 1 - Physique : c'est \u00e9galement le transport effectif du colis; Couche 2 - Lien : le colis arrive au bureau postal; Couche 3 - R\u00e9seau : le bureau de poste d\u00e9termine comment acheminer le colis chez B; Couche 4 - Transport : le cadeau est arriv\u00e9 chez B qui le d\u00e9balle; Couche 5 - Application : B profite de son cadeau. L'int\u00e9r\u00eat de la d\u00e9composition en couches est qu'elle s\u00e9pare un probl\u00e8me complexe en une succession de t\u00e2ches plus simples. Chaque couche n'interagit directement qu'avec ses couches voisines (ce sont les fl\u00e8ches en trait plein) de mani\u00e8re relativement simple . L'interaction de chaque couche chez A avec la couche de m\u00eame niveau chez B est cependant plus complexe (ce sont les fl\u00e8ches en pointill\u00e9s). Couche 1 A - Couche 1 B : c'est le trajet du v\u00e9hicule qui transporte le cadeau; Couche 2 A - Couche 2 B : c'est la planification du trajet; Couche 3 A - Couche 3 B : c'est l'envoi du cadeau au niveau postal; Couche 4 A - Couche 4 B : c'est la phase emballage/d\u00e9ballage; Couche 5 A - Couche 5 B : c'est l'envoi du cadeau de A \u00e0 B. En g\u00e9n\u00e9ral un colis postal est d'un seul tenant mais on peut tr\u00e8s bien imaginer que le cadeau que A veut envoyer \u00e0 B soit tr\u00e8s volumineux (par exemple la collection des romans \u00ab Les Rougon-Macquart \u00bb d'Emile Zola qui comporte 20 livres qui se suivent). Lors de la phase d'emballage, plusieurs \u00abpaquets \u00bb sont cr\u00e9\u00e9s et envoy\u00e9s s\u00e9par\u00e9ment. B ne les re\u00e7oit pas obligatoirement dans l'ordre d'envoi mais ce n'est pas grave car il finit par avoir tous les paquets et remet les romans dans le bon ordre.","title":"L'exemple du r\u00e9seau postal"},{"location":"nsi1/ch18/reseaux.html#un-modele-informatique-tcpip","text":"Un ordinateur A veut envoyer des donn\u00e9es \u00e0 un ordinateur B. On supposera que ces donn\u00e9es sont un fichier . Le processus ressemble \u00e0 l'exemple pr\u00e9c\u00e9dent. On va pr\u00e9senter le mod\u00e8le le plus courant dont le nom est TCP/IP et qu'on peut \u00e9galement mod\u00e9liser avec 5 couches empil\u00e9es. On appelle protocole tout programme utilis\u00e9 par une couche.","title":"Un mod\u00e8le informatique : TCP/IP"},{"location":"nsi1/ch18/reseaux.html#du-point-de-vue-de-lemetteur","text":"Ce qu'il faut retenir c'est que lors de la transmission tr\u00e8s t\u00f4t dans le processus, le fichier est d\u00e9coup\u00e9 en paquets; chaque couche (hormis la couche application) ajoute son propre en-t\u00eate aux donn\u00e9es re\u00e7ues par la couche sup\u00e9rieure et destin\u00e9 \u00e0 la m\u00eame couche pour le destinataire. Ce proc\u00e9d\u00e9 s'appelle encapsulation . Couche 5 - Application Cette couche est charg\u00e9e d'envoyer les donn\u00e9es d'un programme sur l'ordinateur A \u00e0 un programme sur l'ordinateur B. Puisque plusieurs programmes peuvent utiliser la couche transport en m\u00eame temps, il existe 65536 ports et chaque application va utiliser un ou plusieurs ports particuliers. Les num\u00e9ros de ports sont attribu\u00e9s par convention mais il est possible de les changer. Les protocoles les plus connus sont HTTP ( HyperText Transfer Prococol ), protocole de transfert hypertexte, sur le port 80 ou 443 pour sa version s\u00e9curis\u00e9e HTTPS; FTP ( File Transfer Protocol ), protocole de transfert de fichiers, sur les ports 20 et 21, et 990 pour sa version s\u00e9curis\u00e9e FTPS; SMTP ( Simple Mal Transfer Protocol ), charg\u00e9 d'envoyer les emails et POP3 ( Post Office Protocol ) de les r\u00e9cup\u00e9rer; DNS ( Domain Name System ), charg\u00e9 de traduire un nom de site en adresse IP; BitTorrent, charg\u00e9 de r\u00e9cup\u00e9rer et diffuser des fichiers. Couche 4 - Transport Cette couche va d\u00e9couper les donn\u00e9es fournie par la couche 5 en paquets (d'une taille de l'ordre du kilooctet). Elle ajoute \u00e9galement son propre en-t\u00eate \u00e0 chaque paquet. Les protocoles les plus connus sont TCP ( Transfert Control Protocol ), protocole de contr\u00f4le des transmissions, qui est fiable, fonctionne sur le principe d'une connexion avec accus\u00e9 de r\u00e9ception. UDP ( User Datagram Protocol ), non fiable en th\u00e9orie, sans connexion ni accus\u00e9 de r\u00e9ception, mais plus rapide. On utilise TCP lorsque les donn\u00e9es \u00e0 recevoir sont sensibles (t\u00e9l\u00e9chargement d'un fichier). UDP sera pr\u00e9f\u00e9r\u00e9 dans le cas du streaming : le protocole est plus rapide et permet par exemple de visionner un film avec une bonne qualit\u00e9, et si des donn\u00e9es sont perdues, ce n'est pas grave, on passe aux donn\u00e9es suivantes, cela ne perturbe pas trop le film (on ne va pas, comme ce serait le cas pour TCP, attendre que les donn\u00e9es soient arriv\u00e9es, et faire des pauses). Couche 3 - R\u00e9seau Cette couche est responsable de l'aiguillage des paquets vers l'adresse de destination. Elle encapsule les paquets de la couche 4 et y ajoute son propre en-t\u00eate (en g\u00e9n\u00e9ral un en-t\u00eate IP). Du point de vue de cette couche, les paquets sont \u00e0 envoyer \u00e0 un ordinateur muni d'une adresse IP (nombre attribu\u00e9 par ce protocole). Pour que les paquets trouvent leur chemin de l'ordinateur A \u00e0 l'ordinateur B (qui peut \u00eatre \u00e0 plusieurs milliers de kilom\u00e8tres de A), de protocoles de routage sont utilis\u00e9s , les machines d\u00e9di\u00e9es au routage s'appellent des routeurs . Un routeur n'utilise que les couches 1,2 et 3 du mod\u00e8le. Il faut retenir que chaque paquet suit son propre chemin, ind\u00e9pendamment des autres et qu'il a un \u00abtemps de vie\u00bb (pour \u00e9viter, s'il est perdu, de circuler sur le r\u00e9seau pendant des ann\u00e9es). Parmi les protocoles utilis\u00e9s par cette couche on trouve IP ( Internet Protocol ), d\u00e9crit ci-dessus; ARP ( Address Resolution Protocol ) qui permet de trouver l'adresse physique de l'ordinateur connect\u00e9 \u00e0 l'adresse IP. Ce protocole est utilis\u00e9 lorsque l'information est arriv\u00e9e \u00e0 B et \u00abremonte les couches \u00bb. Couche 2 - Lien Elle est charg\u00e9e de coordonner le transfert des donn\u00e9es ainsi que le \u00abtemps de parole \u00bb de chaque machine connect\u00e9e au support physique (si toutes les machines connect\u00e9es \u00e0 un m\u00eame support \u00e9mettent des donn\u00e9es en m\u00eame temps, il risque d'y avoir des collisions ). Elle encapsule les paquets de la couche sup\u00e9rieure dans ce qu'on appelle des trames (trames Ethernet par exemple). Du point de vue de la couche lien, la destination d'un paquet est une adresse physique appel\u00e9e adresse MAC ( Media Access Control ), d\u00e9termin\u00e9e par la carte r\u00e9seau de la machine destinataire. Les protocoles utilis\u00e9s par cette couche sont Ethernet (r\u00e9seau filaire), Wi-Fi (r\u00e9seau via les ondes radios) et Bluetooth (ondes radio \u00e9galement). Couche 1 - Physique Elle est charg\u00e9e de la transmission effective des trames (qu'elle encapsule \u00e9galement) d'un bout \u00e0 l'autre du support physique.","title":"Du point de vue de l'\u00e9metteur"},{"location":"nsi1/ch18/reseaux.html#du-point-de-vue-du-recepteur","text":"`` Il faut retenir que chaque couche d\u00e9paqu\u00e8te le paquet (ou trame) qui lui est adress\u00e9 en enlevant l'en-t\u00eate correspondant et passe le relais \u00e0 la couche du dessus.","title":"Du point de vue du r\u00e9cepteur"},{"location":"nsi1/ch18/reseaux.html#le-materiel","text":"","title":"Le mat\u00e9riel"},{"location":"nsi1/ch18/reseaux.html#couche-physique","text":"Liaison filiaire Les informations peuvent \u00eatre transmises via des c\u00e2bles. Le plus utilis\u00e9 est le c\u00e2ble Ethernet. Son nom est UTP-CAT5 ou UTP-CAT6, la diff\u00e9rence \u00e9tant que le second permet un d\u00e9bit dix fois plus grand que le premier ( 1 Gbit/s contre 100 Mbit/s). Parmi les autres types de liaisons filaires, on compte la liaison par c\u00e2ble t\u00e9l\u00e9phonique (qui permet par exemple de se connecter \u00e0 Internet par ADSL) et la liaison par c\u00e2ble optique. Bluetooth C'est une technologie utilisant les ondes radios pour permettre la communication entre les \u00e9quipements \u00e9lectroniques (imprimantes, t\u00e9l\u00e9phones, scanners, syst\u00e8me audio portatif ou dans un v\u00e9hicule...) \u00e0 courte distance. Ses fonctionnalit\u00e9s sont assez limit\u00e9es en terme de mise en r\u00e9seau. Wi-Fi Cette technologie utilise \u00e9galement les ondes radio. Son nom de norme est IEEE 802.11 et c'est le moyen de transmission des donn\u00e9es sans fil le plus utilis\u00e9. R\u00e9p\u00e9teur Lorsqu'un signal parcourt le support physique, son intensit\u00e9 s'att\u00e9nue avec la distance. Un r\u00e9p\u00e9teur r\u00e9g\u00e9n\u00e8re le signal per\u00e7u avec plus d'intensit\u00e9 pour pallier ce probl\u00e8me. Concentrateur Le concentrateur ( hub ) est moins utilis\u00e9 de nos jours. C'est une version \u00ab multiprise \u00bb du r\u00e9p\u00e9teur : quand il re\u00e7oit un signal sur un des ses branchements, il les recopie sur tous les autres branchements sans se soucier de l'\u00e9ventuel destinataire du signal. Carte r\u00e9seau Que ce soit une cl\u00e9 USB Wi-Fi ou une carte r\u00e9seau interne, c'est la m\u00eame chose : ce composant est indispensable pour connecter un ordinateur \u00e0 un r\u00e9seau. Chaque carte r\u00e9seau poss\u00e8de une adresse MAC : c'est l'adresse physique de la carte, elle permet d'identifier l'ordinateur de mani\u00e8re unique.","title":"Couche physique"},{"location":"nsi1/ch18/reseaux.html#couche-lien","text":"Commutateur Le commutateur ( switch en Anglais) est un \u00e9quipement \u00e0 plusieurs branchements (au moins 2) appel\u00e9s ports (ne pas confondre avec la notion de port utilis\u00e9 par une application). Son r\u00f4le est de rediriger une trame re\u00e7ue vers l'ordinateur de destination.","title":"Couche lien"},{"location":"nsi1/ch18/reseaux.html#couche-reseau","text":"Routeur Le routeur ( router en Anglais) permet d'effectuer le routage des paquets et de les faire transiter d'une partie du r\u00e9seau vers une autre (par exemple d'un r\u00e9seau local \u00e0 un autre, nous verrons cela plus tard).","title":"Couche r\u00e9seau"},{"location":"nsi1/ch18/reseaux.html#couches-superieures","text":"C'est un ordinateur qui ex\u00e9cute les protocoles des couches transport et application. Cela peut \u00eatre un t\u00e9l\u00e9phone, une tablette, un ordinateur portable ou de bureau ou bien encore un objet connect\u00e9 tel qu'une enceinte Bluetooth.","title":"Couches sup\u00e9rieures"},{"location":"nsi1/ch19/reseau_local.html","text":"Le r\u00e9seau local \u2693\ufe0e Un r\u00e9seau local , ou LAN ( Local Area Network ) est de taille modeste. Les \u00e9quipements qui y sont connect\u00e9s s'envoient des donn\u00e9es entre eux sans passer par internet. Un bon exemple de LAN est le r\u00e9seau domestique d'une maison : la box, fournie par l'op\u00e9rateur (Orange, Free, Bouygues...) fait office de switch et de routeur; les t\u00e9l\u00e9phones portables, tablettes, ordinateurs, imprimantes et autres s'y int\u00e8grent. Les adresses IP priv\u00e9es et publiques \u2693\ufe0e On a vu dans le chapitre pr\u00e9c\u00e9dent l'importance de l'adresse IP d'un ordinateur dans le r\u00f4le de la communication. D\u00e9finition : Adresse IP Une adresse IP (version 4) est la donn\u00e9e de 4 octets. On les note s\u00e9par\u00e9s par des points. Il y a 5 classes d'adresse IP, not\u00e9es A, B, C, D et E et les 3 premi\u00e8res classes disposent d'adresses IP (on abr\u00e8gera en IP) publiques et priv\u00e9es. Voici des exemples: 74.125.21.138 est \u00e0 ce jour une IP permettant d'acc\u00e9der au site du moteur de recherche de Google. C'est une IP publique , accessible par tout le monde via Internet. 192.168.1.47 est l'IP de l'ordinateur sur lequel j'\u00e9cris ces lignes. C'est une IP priv\u00e9e : elle n'est accessible que par les ordinateurs de mon propre r\u00e9seau domestique. Elle n'est d'ailleurs pas unique non plus dans le sens o\u00f9 d'autre r\u00e9seaux domestiques utilisent cette IP. lorsque je veux voir mon IP publique, je vais par exemple consulter ce site et je trouve une adresse diff\u00e9rente : 90.59.223.xxx (permettez moi de garder mon adresse IP secr\u00e8te). Une adresse IP publique, c'est un peu comme une adresse postale publique : elle identifie de mani\u00e8re unique une machine (qui peut \u00eatre une box jouant le r\u00f4le de routeur vers un r\u00e9seau domestique). Dans un r\u00e9seau local, une adresse priv\u00e9e, c'est un peu comme dans une ville, le num\u00e9ro et le nom de la rue (sans la ville ni le pays) : il y a sans doute beaucoup d'adresses qui commencent par \u00ab 24 rue des oliviers \u00bb. Si le r\u00e9seau postal ne concerne que la ville de Rennes, cette adresse est suffisante, mais si je cherche \u00e0 envoyer du courrier au 24 rue des oliviers sans pr\u00e9ciser la ville, cela ne marchera pas. Remarque 4 octets pour une adresse IP, c'\u00e9tait bien il y a 30 ans, \u00e7a l'est beaucoup moins de nos jours ! \\(2^{32}=\\) 4 294 967 296, donc vu le nombre de machines croissant en fonctionnement simultan\u00e9 sur Terre, il est impossible d'attribuer une IP unique \u00e0 chaque ordinateur connect\u00e9 \u00e0 Internet, d'o\u00f9 l'importance du LAN. Pour pallier le probl\u00e8me, une norme IP version 6, plus performante, sur 128 bits au lieu de 32, a vu le jour mais peine encore \u00e0 s'imposer. Voici les plages d'IP et d'IP priv\u00e9es selon les classes : Classe A : de l\u2019adresse IP 0.0.0.0 \u00e0 126.255.255.255. Adresses priv\u00e9es : de 10.0.0.0 \u00e0 10.255.255.255 (avec 16 millions d\u2019adresses possibles au sein d'un r\u00e9seau local) Classe B : de l\u2019adresse IP 128.0.0.0 \u00e0 191.255.255.255. Adresses priv\u00e9es : 172.16.0.0 \u00e0 172.31.255.255 (avec 65535 adresses possibles au sein d'un r\u00e9seau local) Classe C : de l\u2019adresse IP 192.0.0.0 \u00e0 223.255.255.255 Adresses priv\u00e9es C : 192.168.1.0 \u00e0 192.168.255.255 (255 adresses possibles dans un r\u00e9seau local) Classe D (r\u00e9serv\u00e9e) : de l\u2019adresse IP 224.0.0.0 \u00e0 239.255.255.255 Ces adresses sont r\u00e9serv\u00e9es pour le multicast . Classe E (r\u00e9serv\u00e9e) : de l\u2019adresse IP 240.0.0.0 \u00e0 255.255.255.255 Ces adresses sont r\u00e9serv\u00e9s par l' IANA Mon adresse IP publique est une IP de classe A, mon IP priv\u00e9e est de taille C, ce que je comprends parfaitement puisque mon r\u00e9seau domestique ne contiendra qu'une dizaine de terminaux tout au plus. L'exemple du r\u00e9seau local traditionnel \u2693\ufe0e Lorsqu'on met en place un r\u00e9seau local, on commence par d\u00e9terminer sa taille. Il y a beaucoup de chances qu'on ait moins de 256 machines \u00e0 connecter donc on va choisir une IP publique de classe C : je choisis de prendre pour adresse r\u00e9seau 192.168.1.0, ce n'est pas une IP attribu\u00e9e \u00e0 une machine, elle d\u00e9signe mon r\u00e9seau local; le masque de sous-r\u00e9seau par d\u00e9faut est 255.255.255.0, ce qui signifie que les 3 premiers octets des machines de mon r\u00e9seau sont \u00ab bloqu\u00e9s \u00bb et donc que les machines vont avoir des adresses du type 192.168.1.xx; je peux attribuer des IP aux machines que je veux connecter, par exemple 192.168.1.1 pour la premi\u00e8re, et caetera; la derni\u00e8re IP 192.168.1.255 est interdite, elle est r\u00e9serv\u00e9e pour adresser un message \u00e0 l'ensemble des machines du r\u00e9seau (on appelle ceci broadcast ). Remarque Prenons le cas d'un foyer qui utilise le FAI Orange. Par d\u00e9faut le r\u00e9seau local est 192.168.1.0. avec pour masque 255.255.255.0. La LiveBox, qui fait office de switch et de routeur, a pour adresse 192.168.1.1. C'est cette adresse qui est utilis\u00e9e comme passerelle pour acc\u00e9der \u00e0 internet : La commande ipconfig de Windows ( ifconfig sous Linux et Mac) me permet de retrouver ces informations ainsi que mon IP priv\u00e9e. Utilise l'invite de commande de ton syst\u00e8me d'exploitation (touche Win et taper cmd pour Windows, Terminal sous MacOS) et trouve l'IP de ton ordinateur, le masque de sous-r\u00e9seau et l'adresse de la passerelle. Un outil de simulation r\u00e9seau : Filius \u2693\ufe0e Filius est un logiciel libre fonctionnant sur tous les syst\u00e8mes d'exploitation et permettant de simuler le fonctionnement d'un petit r\u00e9seau. On peut ajouter du mat\u00e9riel : ordinateur, switch, routeur et modem; connecter les \u00e9l\u00e9ments pr\u00e9c\u00e9dents; configurer ces \u00e9l\u00e9ments; installer de petites applications sur les ordinateurs connect\u00e9s pour transmettre ou recevoir des donn\u00e9es sur le(s) r\u00e9seau(x); visualiser les \u00e9changes de donn\u00e9es. Nous utiliserons Filius pour observer ce que nous avons appris des r\u00e9seaux. Activit\u00e9 L'activit\u00e9 sur Filius se trouve ici","title":"CH19 : R\u00e9seau local"},{"location":"nsi1/ch19/reseau_local.html#le-reseau-local","text":"Un r\u00e9seau local , ou LAN ( Local Area Network ) est de taille modeste. Les \u00e9quipements qui y sont connect\u00e9s s'envoient des donn\u00e9es entre eux sans passer par internet. Un bon exemple de LAN est le r\u00e9seau domestique d'une maison : la box, fournie par l'op\u00e9rateur (Orange, Free, Bouygues...) fait office de switch et de routeur; les t\u00e9l\u00e9phones portables, tablettes, ordinateurs, imprimantes et autres s'y int\u00e8grent.","title":"Le r\u00e9seau local"},{"location":"nsi1/ch19/reseau_local.html#les-adresses-ip-privees-et-publiques","text":"On a vu dans le chapitre pr\u00e9c\u00e9dent l'importance de l'adresse IP d'un ordinateur dans le r\u00f4le de la communication. D\u00e9finition : Adresse IP Une adresse IP (version 4) est la donn\u00e9e de 4 octets. On les note s\u00e9par\u00e9s par des points. Il y a 5 classes d'adresse IP, not\u00e9es A, B, C, D et E et les 3 premi\u00e8res classes disposent d'adresses IP (on abr\u00e8gera en IP) publiques et priv\u00e9es. Voici des exemples: 74.125.21.138 est \u00e0 ce jour une IP permettant d'acc\u00e9der au site du moteur de recherche de Google. C'est une IP publique , accessible par tout le monde via Internet. 192.168.1.47 est l'IP de l'ordinateur sur lequel j'\u00e9cris ces lignes. C'est une IP priv\u00e9e : elle n'est accessible que par les ordinateurs de mon propre r\u00e9seau domestique. Elle n'est d'ailleurs pas unique non plus dans le sens o\u00f9 d'autre r\u00e9seaux domestiques utilisent cette IP. lorsque je veux voir mon IP publique, je vais par exemple consulter ce site et je trouve une adresse diff\u00e9rente : 90.59.223.xxx (permettez moi de garder mon adresse IP secr\u00e8te). Une adresse IP publique, c'est un peu comme une adresse postale publique : elle identifie de mani\u00e8re unique une machine (qui peut \u00eatre une box jouant le r\u00f4le de routeur vers un r\u00e9seau domestique). Dans un r\u00e9seau local, une adresse priv\u00e9e, c'est un peu comme dans une ville, le num\u00e9ro et le nom de la rue (sans la ville ni le pays) : il y a sans doute beaucoup d'adresses qui commencent par \u00ab 24 rue des oliviers \u00bb. Si le r\u00e9seau postal ne concerne que la ville de Rennes, cette adresse est suffisante, mais si je cherche \u00e0 envoyer du courrier au 24 rue des oliviers sans pr\u00e9ciser la ville, cela ne marchera pas. Remarque 4 octets pour une adresse IP, c'\u00e9tait bien il y a 30 ans, \u00e7a l'est beaucoup moins de nos jours ! \\(2^{32}=\\) 4 294 967 296, donc vu le nombre de machines croissant en fonctionnement simultan\u00e9 sur Terre, il est impossible d'attribuer une IP unique \u00e0 chaque ordinateur connect\u00e9 \u00e0 Internet, d'o\u00f9 l'importance du LAN. Pour pallier le probl\u00e8me, une norme IP version 6, plus performante, sur 128 bits au lieu de 32, a vu le jour mais peine encore \u00e0 s'imposer. Voici les plages d'IP et d'IP priv\u00e9es selon les classes : Classe A : de l\u2019adresse IP 0.0.0.0 \u00e0 126.255.255.255. Adresses priv\u00e9es : de 10.0.0.0 \u00e0 10.255.255.255 (avec 16 millions d\u2019adresses possibles au sein d'un r\u00e9seau local) Classe B : de l\u2019adresse IP 128.0.0.0 \u00e0 191.255.255.255. Adresses priv\u00e9es : 172.16.0.0 \u00e0 172.31.255.255 (avec 65535 adresses possibles au sein d'un r\u00e9seau local) Classe C : de l\u2019adresse IP 192.0.0.0 \u00e0 223.255.255.255 Adresses priv\u00e9es C : 192.168.1.0 \u00e0 192.168.255.255 (255 adresses possibles dans un r\u00e9seau local) Classe D (r\u00e9serv\u00e9e) : de l\u2019adresse IP 224.0.0.0 \u00e0 239.255.255.255 Ces adresses sont r\u00e9serv\u00e9es pour le multicast . Classe E (r\u00e9serv\u00e9e) : de l\u2019adresse IP 240.0.0.0 \u00e0 255.255.255.255 Ces adresses sont r\u00e9serv\u00e9s par l' IANA Mon adresse IP publique est une IP de classe A, mon IP priv\u00e9e est de taille C, ce que je comprends parfaitement puisque mon r\u00e9seau domestique ne contiendra qu'une dizaine de terminaux tout au plus.","title":"Les adresses IP priv\u00e9es et publiques"},{"location":"nsi1/ch19/reseau_local.html#lexemple-du-reseau-local-traditionnel","text":"Lorsqu'on met en place un r\u00e9seau local, on commence par d\u00e9terminer sa taille. Il y a beaucoup de chances qu'on ait moins de 256 machines \u00e0 connecter donc on va choisir une IP publique de classe C : je choisis de prendre pour adresse r\u00e9seau 192.168.1.0, ce n'est pas une IP attribu\u00e9e \u00e0 une machine, elle d\u00e9signe mon r\u00e9seau local; le masque de sous-r\u00e9seau par d\u00e9faut est 255.255.255.0, ce qui signifie que les 3 premiers octets des machines de mon r\u00e9seau sont \u00ab bloqu\u00e9s \u00bb et donc que les machines vont avoir des adresses du type 192.168.1.xx; je peux attribuer des IP aux machines que je veux connecter, par exemple 192.168.1.1 pour la premi\u00e8re, et caetera; la derni\u00e8re IP 192.168.1.255 est interdite, elle est r\u00e9serv\u00e9e pour adresser un message \u00e0 l'ensemble des machines du r\u00e9seau (on appelle ceci broadcast ). Remarque Prenons le cas d'un foyer qui utilise le FAI Orange. Par d\u00e9faut le r\u00e9seau local est 192.168.1.0. avec pour masque 255.255.255.0. La LiveBox, qui fait office de switch et de routeur, a pour adresse 192.168.1.1. C'est cette adresse qui est utilis\u00e9e comme passerelle pour acc\u00e9der \u00e0 internet : La commande ipconfig de Windows ( ifconfig sous Linux et Mac) me permet de retrouver ces informations ainsi que mon IP priv\u00e9e. Utilise l'invite de commande de ton syst\u00e8me d'exploitation (touche Win et taper cmd pour Windows, Terminal sous MacOS) et trouve l'IP de ton ordinateur, le masque de sous-r\u00e9seau et l'adresse de la passerelle.","title":"L'exemple du r\u00e9seau local traditionnel"},{"location":"nsi1/ch19/reseau_local.html#un-outil-de-simulation-reseau-filius","text":"Filius est un logiciel libre fonctionnant sur tous les syst\u00e8mes d'exploitation et permettant de simuler le fonctionnement d'un petit r\u00e9seau. On peut ajouter du mat\u00e9riel : ordinateur, switch, routeur et modem; connecter les \u00e9l\u00e9ments pr\u00e9c\u00e9dents; configurer ces \u00e9l\u00e9ments; installer de petites applications sur les ordinateurs connect\u00e9s pour transmettre ou recevoir des donn\u00e9es sur le(s) r\u00e9seau(x); visualiser les \u00e9changes de donn\u00e9es. Nous utiliserons Filius pour observer ce que nous avons appris des r\u00e9seaux. Activit\u00e9 L'activit\u00e9 sur Filius se trouve ici","title":"Un outil de simulation r\u00e9seau : Filius"},{"location":"nsi1/ch20/controle_de_transmission.html","text":"Contr\u00f4le de transmission \u2693\ufe0e Le protocole du bit altern\u00e9 \u2693\ufe0e Nous allons ici voir un mod\u00e8le de contr\u00f4le de perte de donn\u00e9es appel\u00e9 protocole du bit altern\u00e9 . Ce protocole a (ou plut\u00f4t avait car il a \u00e9t\u00e9 remplac\u00e9 par un protocole plus performant) lieu au sein de la couche 2 (couche lien) et permet de v\u00e9rifier que les trames d'un ordinateur A sont bien re\u00e7ues par un ordinateur B. Le principe est tr\u00e8s simple, il utilise les acquittements et les flags : lorsque A envoie une trame, il attend un accus\u00e9 de r\u00e9ception (acquittement, acknowledgment en Anglais) de la part de B dans un temps imparti. \u00c0 ceci s'ajoute un bit de contr\u00f4le, appel\u00e9 flag en Anglais, qui alterne suivant le mod\u00e8le suivant: la communication commence avec le flag \u00e0 0, A envoie une premi\u00e8re trame avec le flag ; B re\u00e7oit la trame et accuse r\u00e9ception en envoyant une trame d'acquittement not\u00e9e ACK. le flag est chang\u00e9 \u00e0 1; A re\u00e7oit ACK avec le flag 1 et envoie donc la deuxi\u00e8me trame avec ce flag 1; et ainsi de suite : Lorsque A re\u00e7oit une trame de B, elle garde la valeur du flag pour la prochaine trame qu'elle envoie. B, quant \u00e0 lui change toujours le flag entre le moment o\u00f9 il re\u00e7oit et celui ou il \u00e9met. Ce protocole permet d'\u00e9viter la perte de trames dans les cas suivants : Perte de trame du c\u00f4t\u00e9 de A \u2693\ufe0e A envoie la premi\u00e8re trame et celle-ci se perd, au bout du temps imparti, ne re\u00e7oit rien. C'est ce qu'on appelle un timeout en Anglais. A renvoie donc sa trame comme si de rien n'\u00e9tait. Perte de trame du c\u00f4t\u00e9 de B \u2693\ufe0e A envoie la premi\u00e8re trame et celle-ci arrive \u00e0 B, qui renvoie un ACK avec un flag \u00e0 1, et s'attend donc \u00e0 recevoir une prochaine trame avec un flag \u00e0 1. Cette trame ACK se perd. Donc du point de vue de A, il y a timeout et il renvoie la m\u00eame trame avec le flag \u00e0 0. B se rend compte que quelque chose ne va pas, et renvoie donc l'ACK pr\u00e9c\u00e9dent, avec son flag \u00e0 1. La communication continue normalement.} Ce protocole pr\u00e9sente des insuffisances comme le montre l'exercice suivant Exercice : perte d'information Analyse le sch\u00e9ma suivant et explique pourquoi il y a perte d'information. D\u00e9roulement d'une communication TCP \u2693\ufe0e On rappelle que TCP est un protocole de la couche 4 (couche transport) dont les caract\u00e9ristiques principales sont les suivantes : il commence par \u00e9tablir une connexion entre les deux machines; il d\u00e9coupe les donn\u00e9es en paquets; il s'assure de la bonne r\u00e9ception des donn\u00e9es au moyen d'\\textit{accus\u00e9s de r\u00e9ception}; il met fin \u00e0 la connexion. L'exercice suivant va nous permettre d'examiner une exemple de communication TCP en d\u00e9tail. Exercice : une communication TCP en d\u00e9tail Reprendre le fichier Filius de l'exercice 5 (serveur web avec DNS ) de la feuille de TP sur Filius. Tu peux aussi le t\u00e9l\u00e9charger ici . En mode simulation, faire un clic droit sur 192.168.2.1 et afficher les \u00e9changes de donn\u00e9es. Normalement il n'y a encore eu aucune communication r\u00e9seau donc la fen\u00eatre d'\u00e9change est vide. Sur le navigateur web install\u00e9 sur 192.168.2.1, entrer monsite.com et observer la fen\u00eatre d'\u00e9change de donn\u00e9es du point de vue de 192.168.2.1 : On observe 29 trames. Il est possible de cliquer sur chacune d'entre elles pour visualiser son contenu. Voici le contenu de la premi\u00e8re : Il nous indique que 192.168.2.1 essaie de d\u00e9terminer l'adresse MAC du routeur. En effet, 192.168.2.1 doit interroger le serveur DNS, situ\u00e9 en 192.168.3.1, pour obtenir l'adresse IP associ\u00e9e \u00e0 monsite.com , et puisque 192.168.3.1 n'est pas dans le m\u00eame r\u00e9seau que 192.168.2.1, celui-ci utilise la passerelle (le routeur). La trame suivante est la r\u00e9ponse ARP et la communication se poursuit. Regarder la source, la destination et le contenu des trames 3 et 4. \u00c0 quoi correspondent-elles ? On s'int\u00e9resse au d\u00e9but de la connexion TCP de 192.168.1.2.1 \u00e0 192.168.3.1 : ce sont les trames 5,6 et 7, qui constituent ce qu'on appelle en Anglais un Three-way handshake . Rechercher ce terme sur Wikip\u00e9dia et interpr\u00e9ter ensuite les 3 trames. Les trames 8 \u00e0 25 constituent l'\u00e9change de donn\u00e9es en lui-m\u00eame. Il y a deux grandes \u00e9tapes. Lesquelles ? Que repr\u00e9sentent les trames 26 \u00e0 29 ? D\u00e9tailler le proc\u00e9d\u00e9.","title":"CH20 : Contr\u00f4le de transmission"},{"location":"nsi1/ch20/controle_de_transmission.html#controle-de-transmission","text":"","title":"Contr\u00f4le de transmission"},{"location":"nsi1/ch20/controle_de_transmission.html#le-protocole-du-bit-alterne","text":"Nous allons ici voir un mod\u00e8le de contr\u00f4le de perte de donn\u00e9es appel\u00e9 protocole du bit altern\u00e9 . Ce protocole a (ou plut\u00f4t avait car il a \u00e9t\u00e9 remplac\u00e9 par un protocole plus performant) lieu au sein de la couche 2 (couche lien) et permet de v\u00e9rifier que les trames d'un ordinateur A sont bien re\u00e7ues par un ordinateur B. Le principe est tr\u00e8s simple, il utilise les acquittements et les flags : lorsque A envoie une trame, il attend un accus\u00e9 de r\u00e9ception (acquittement, acknowledgment en Anglais) de la part de B dans un temps imparti. \u00c0 ceci s'ajoute un bit de contr\u00f4le, appel\u00e9 flag en Anglais, qui alterne suivant le mod\u00e8le suivant: la communication commence avec le flag \u00e0 0, A envoie une premi\u00e8re trame avec le flag ; B re\u00e7oit la trame et accuse r\u00e9ception en envoyant une trame d'acquittement not\u00e9e ACK. le flag est chang\u00e9 \u00e0 1; A re\u00e7oit ACK avec le flag 1 et envoie donc la deuxi\u00e8me trame avec ce flag 1; et ainsi de suite : Lorsque A re\u00e7oit une trame de B, elle garde la valeur du flag pour la prochaine trame qu'elle envoie. B, quant \u00e0 lui change toujours le flag entre le moment o\u00f9 il re\u00e7oit et celui ou il \u00e9met. Ce protocole permet d'\u00e9viter la perte de trames dans les cas suivants :","title":"Le protocole du bit altern\u00e9"},{"location":"nsi1/ch20/controle_de_transmission.html#perte-de-trame-du-cote-de-a","text":"A envoie la premi\u00e8re trame et celle-ci se perd, au bout du temps imparti, ne re\u00e7oit rien. C'est ce qu'on appelle un timeout en Anglais. A renvoie donc sa trame comme si de rien n'\u00e9tait.","title":"Perte de trame du c\u00f4t\u00e9 de A"},{"location":"nsi1/ch20/controle_de_transmission.html#perte-de-trame-du-cote-de-b","text":"A envoie la premi\u00e8re trame et celle-ci arrive \u00e0 B, qui renvoie un ACK avec un flag \u00e0 1, et s'attend donc \u00e0 recevoir une prochaine trame avec un flag \u00e0 1. Cette trame ACK se perd. Donc du point de vue de A, il y a timeout et il renvoie la m\u00eame trame avec le flag \u00e0 0. B se rend compte que quelque chose ne va pas, et renvoie donc l'ACK pr\u00e9c\u00e9dent, avec son flag \u00e0 1. La communication continue normalement.} Ce protocole pr\u00e9sente des insuffisances comme le montre l'exercice suivant Exercice : perte d'information Analyse le sch\u00e9ma suivant et explique pourquoi il y a perte d'information.","title":"Perte de trame du c\u00f4t\u00e9 de B"},{"location":"nsi1/ch20/controle_de_transmission.html#deroulement-dune-communication-tcp","text":"On rappelle que TCP est un protocole de la couche 4 (couche transport) dont les caract\u00e9ristiques principales sont les suivantes : il commence par \u00e9tablir une connexion entre les deux machines; il d\u00e9coupe les donn\u00e9es en paquets; il s'assure de la bonne r\u00e9ception des donn\u00e9es au moyen d'\\textit{accus\u00e9s de r\u00e9ception}; il met fin \u00e0 la connexion. L'exercice suivant va nous permettre d'examiner une exemple de communication TCP en d\u00e9tail. Exercice : une communication TCP en d\u00e9tail Reprendre le fichier Filius de l'exercice 5 (serveur web avec DNS ) de la feuille de TP sur Filius. Tu peux aussi le t\u00e9l\u00e9charger ici . En mode simulation, faire un clic droit sur 192.168.2.1 et afficher les \u00e9changes de donn\u00e9es. Normalement il n'y a encore eu aucune communication r\u00e9seau donc la fen\u00eatre d'\u00e9change est vide. Sur le navigateur web install\u00e9 sur 192.168.2.1, entrer monsite.com et observer la fen\u00eatre d'\u00e9change de donn\u00e9es du point de vue de 192.168.2.1 : On observe 29 trames. Il est possible de cliquer sur chacune d'entre elles pour visualiser son contenu. Voici le contenu de la premi\u00e8re : Il nous indique que 192.168.2.1 essaie de d\u00e9terminer l'adresse MAC du routeur. En effet, 192.168.2.1 doit interroger le serveur DNS, situ\u00e9 en 192.168.3.1, pour obtenir l'adresse IP associ\u00e9e \u00e0 monsite.com , et puisque 192.168.3.1 n'est pas dans le m\u00eame r\u00e9seau que 192.168.2.1, celui-ci utilise la passerelle (le routeur). La trame suivante est la r\u00e9ponse ARP et la communication se poursuit. Regarder la source, la destination et le contenu des trames 3 et 4. \u00c0 quoi correspondent-elles ? On s'int\u00e9resse au d\u00e9but de la connexion TCP de 192.168.1.2.1 \u00e0 192.168.3.1 : ce sont les trames 5,6 et 7, qui constituent ce qu'on appelle en Anglais un Three-way handshake . Rechercher ce terme sur Wikip\u00e9dia et interpr\u00e9ter ensuite les 3 trames. Les trames 8 \u00e0 25 constituent l'\u00e9change de donn\u00e9es en lui-m\u00eame. Il y a deux grandes \u00e9tapes. Lesquelles ? Que repr\u00e9sentent les trames 26 \u00e0 29 ? D\u00e9tailler le proc\u00e9d\u00e9.","title":"D\u00e9roulement d'une communication TCP"},{"location":"nsi1/initiation_au_shell_linux/activite.html","text":"Initiation au shell Linux \u2693\ufe0e Cette activit\u00e9 est bas\u00e9e sur un travail original de Martin Quinson Petit tutoriel \u2693\ufe0e Comme les autres syst\u00e8mes d'exploitation, Linux range les fichiers dans une arborescence de r\u00e9pertoires. Voici quelques commandes utiles. Tapez-les une \u00e0 une pour constater le r\u00e9sultat. #!bashpwd savoir o\u00f9 on est sur le disque (Print Working Directory) !bashmkdir machin` cr\u00e9er un nouveau r\u00e9pertoire nomm\u00e9 machin \u2693\ufe0e ls lister les fichiers et r\u00e9pertoires du r\u00e9pertoire courant cd machin entrer dans le r\u00e9pertoire machin (Change Directory) pwd cd .. aller dans le r\u00e9pertoire \"..\", c'est-\u00e0-dire un \u00e9tage plus haut pwd touch bidule cr\u00e9er un fichier vide nomm\u00e9 bidule (ou change sa date d'acc\u00e8s si le fichier existe) ls rm bidule effacer le fichier bidule. Attention, c'est une op\u00e9ration irr\u00e9versible. ls rmdir machin effacer le r\u00e9pertoire machin (il faut qu'il soit vide). On peut aussi utiliser rm -r machin pour effacer r\u00e9cursivement machin et tout son contenu. ls clear permet d'effacer l'\u00e9cran pour nettoyer. Au besoin, lisez la documentation de ces commandes avec par exemple man ls ( Q pour quiter cette aide). Sachez aussi que : les touches Up et Down du clavier permettent de naviguer dans l'historique des commandes d\u00e9j\u00e0 tap\u00e9es la touche Tab (tabulation) permet de compl\u00e9ter un nom de fichier 1. Cr\u00e9er des arborescences \u2693\ufe0e Il s'agit maintenant de cr\u00e9er l'aborescence suivante. \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 dir1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 dir2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 doc1 \u2514\u2500\u2500 \ud83d\udcc1 dir3 \u2514\u2500\u2500 \ud83d\uddb9 doc2 Les logos sont juste l\u00e0 pour l'explication, les noms de fichiers et r\u00e9pertoires ne doivent contenir que des lettres et des chiffres dans cet exercice. Le r\u00e9pertoire au sommet est l'endroit o\u00f9 commence l'exercice, not\u00e9 EXO . Pour commencer l'exercice, dans le terminal, entrez bash 01_start Coinc\u00e9? Utilisez la commande ls -R pour afficher r\u00e9cursivement le contenu de tous les r\u00e9pertoires. Si c'est plus grave, tapez cd pour revenir au r\u00e9pertoire de d\u00e9part et bash 01_start pour tout recommencer. Lorsque vous avez termin\u00e9, tapez bash 01_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant. 2. Renommer et d\u00e9placer \u2693\ufe0e Nous avons vu quelques commandes pour se d\u00e9placer sur le disque et pour cr\u00e9er des fichiers et r\u00e9pertoires. Pour ne pas les oublier, imprimez le pense-b\u00eate du shell . Dans cet exercice, nous allons apprendre \u00e0 d\u00e9placer des fichiers. Petit tutoriel \u2693\ufe0e Pour commencer, dans le terminal, entrez bash 02_start Utilisez la commande tree pour voir la situation initiale. La commande mv permet de d\u00e9placer (MoVe) des fichiers et r\u00e9pertoires. Sa syntaxe est tr\u00e8s facile : De base, mv toto bidule permet de renommer le fichier toto en bidule . Cela marche aussi si toto est un r\u00e9pertoire. V\u00e9rifiez le r\u00e9sultat avec la commande tree . Si le second param\u00e8tre de la commande mv existe, \u00e7a doit \u00eatre un r\u00e9pertoire dans lequel le premier param\u00e8tre est d\u00e9plac\u00e9. Par exemple mv bidule dir1 d\u00e9place le fichier bidule dans le r\u00e9pertoire dir1 . V\u00e9rifiez l'\u00e9tat courant avec tree ou ls -R (listing r\u00e9cursif). Enfin, si vous passez plus de deux param\u00e8tres \u00e0 la commande mv , tous ceux du d\u00e9but de la ligne sont d\u00e9plac\u00e9s dans le r\u00e9pertoire indiqu\u00e9 en dernier param\u00e8tre. Par exemple mv machin dir1/bidule truc d\u00e9place les fichiers machin et dir1/bidule (c'est-\u00e0-dire le fichier bidule plac\u00e9 dans dir1 ) dans le r\u00e9pertoire truc . V\u00e9rifiez l'\u00e9tat actuel avec tree . La commande mv , comme beaucoup d'autres, accepte beaucoup de param\u00e8tres int\u00e9ressants. Par exemple mv -i [ param\u00e8tres habituels ] passe en mode interactif : vous devez confirmer chaque op\u00e9ration qui \u00e9crase un fichier existant. Consultez le manuel de cette commande en tapant man mv . Au travail \u2693\ufe0e Si vous avez bien suivi le tutoriel, votre arborescence devrait \u00eatre la suivante: \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 dir1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 dir2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 doc1 \u2514\u2500\u2500 \ud83d\udcc1 dir3 \u2514\u2500\u2500 \ud83d\uddb9 doc2 L'objectif est de renommer tous les \u00e9l\u00e9ments pour les mettre en majuscule, comme suit. Il n'est pas possible de juste recr\u00e9er l'arborescence, car le contenu des fichiers doc1 et doc2 doit \u00eatre pr\u00e9serv\u00e9. \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 DIR1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 DIR2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 DOC1 \u2514\u2500\u2500 \ud83d\udcc1 DIR3 \u2514\u2500\u2500 \ud83d\uddb9 DOC2 Coinc\u00e9? Utilisez la commande tree pour afficher r\u00e9cursivement le contenu de tous les r\u00e9pertoires. Si c'est plus grave, tapez cd pour revenir au r\u00e9pertoire de d\u00e9part et bash 02_start pour tout recommencer. Lorsque vous avez termin\u00e9, tapez bash 02_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant. 3. D\u00e9placer en masse \u2693\ufe0e Bien. Vous avez compris comment d\u00e9placer des fichiers en shell. Mais avouez que c'est assez r\u00e9barbatif : on irait beaucoup plus vite \u00e0 la souris avec un bon navigateur de fichiers. Alors, \u00e0 quoi bon utiliser le shell ? Eh bien, parce que les op\u00e9rations non triviales vont beaucoup plus vite \u00e0 r\u00e9aliser en shell ! Dans le terminal, entrez bash 03_start . Affichez le contenu du r\u00e9pertoire EXO . C'est le bazar, non ? Heureusement pour vous, la commande mv *.html web va d\u00e9placer tous les fichiers dont le nom termine par .html dans le r\u00e9pertoire web (et seulement ceux-l\u00e0). \u00c0 la souris, il serait fastidieux de devoir les s\u00e9lectionner les uns apr\u00e8s les autres. Dans cet exercice, il vous est demand\u00e9 de d\u00e9placer tous les fichiers html dans le r\u00e9pertoire web , les fichiers pdf dans le r\u00e9pertoire print (que vous devez cr\u00e9er) et les fichiers png dans le r\u00e9pertoire image . Avouez que pouvoir d\u00e9placer autant de fichiers en une seule commande est tout de m\u00eame agr\u00e9able, non ? Pour (re)commencer l'exercice, dans le terminal, entrez bash 03_start . Lorsque vous avez termin\u00e9, tapez bash 03_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant. 4. Lire le contenu des fichiers \u2693\ufe0e Commencez donc par un petit bash 04_start . Il existe de nombreuses commandes pour afficher le contenu des fichiers \u00e0 l'\u00e9cran. La plus simple est cat fichier , qui affiche le contenu du fichier sur la console. Si on affiche un fichier contenant non pas du texte mais du binaire, on peut avoir des r\u00e9sultats surprenants: cat fichier-binaire affiche un fichier peu intelligible en l'\u00e9tat. Si votre terminal est ... d\u00e9rang\u00e9 apr\u00e8s un tel affichage, il suffit de taper reset pour tout r\u00e9initialiser. Si le fichier est plus long, cette m\u00e9thode permet assez facilement de voir la fin du contenu. C'est d\u00e9j\u00e0 \u00e7a. Par exemple, cat fichier_long risque de vous remplir l'\u00e9cran. Et si on demande \u00e0 afficher un programme binaire, c'est long ET illisible \u00e0 priori: cat /bin/cat affiche le programme cat lui-m\u00eame. Si on veut voir le d\u00e9but d'un fichier, on peut utiliser la commande head fichier_long qui n'affiche que les premi\u00e8res lignes du fichier pass\u00e9. On peut aussi pr\u00e9ciser que l'on veut les 50 premi\u00e8res lignes avec l'option -n : head -n 50 fichier_long De m\u00eame, la commande tail -n 10 fichier_long permet d'afficher les 10 derni\u00e8res lignes d'un fichier long. Enfin, la commande less fichier_long permet de se promener dans l'affichage d'un fichier : la navigation se fait avec les m\u00eames raccourcis que le manuel (le manuel appelle less en interne). Pour rappel : les fl\u00e8ches et page vers le haut/bas permettent de se d\u00e9placer dans le fichier, Q quitte le programme et on voit l'aide avec H . But de l'exercice \u2693\ufe0e Pour passer \u00e0 la suite, il suffit de trouver diff\u00e9rents mots de passe, r\u00e9partis dans diff\u00e9rents fichiers du r\u00e9pertoire. Normalement Ctrl + C ne fonctionne pas dans le terminal et il faut s\u00e9lectionner \u00e0 la souris puis faire Ctrl + Ins pour copier, et Shift + Ins pour coller. Ceci dit, dans CoCalc, les d\u00e9veloppeurs ont eu la bonne id\u00e9e d'autoriser \u00e9galement les bons vieux Ctrl + C pour copier et Ctrl + V pour coller, donc il ne faut pas vous en priver. Bien entendu, il est presque impossible de taper la bonne commande, juste du premier coup. On pourrait la copier/coller depuis juste au dessus avec Ctrl + Ins et Shift + Ins , mais ce serait affreusement lent et frustrant. Il y a bien mieux : on peut retrouver les commandes qu'on vient d'\u00e9crire simplement avec les fl\u00e8ches haut/bas et les modifier. En fait, le terminal est un truc de fain\u00e9ants o\u00f9 tout est fait pour vous simplifier la vie, vous allez voir. Vous avez la flemme de chercher manuellement dans l'historique la ligne o\u00f9 vous utilisez head ? Tapez simplement Ctrl + R pour passer en mode recherche, et \u00e9crivez head . Le shell va fouiller l'historique pour vous. Appuyez sur Entr\u00e9e quand vous l'avez trouv\u00e9. Essayez aussi d'utiliser les fl\u00e8ches pendant/apr\u00e8s la recherche ou de refaire Ctrl + R en cours de recherche: c'est assez bien fait. Quel est le contenu du fichier mot-de-passe ? Quelle information se cache \u00e0 la fin du fichier cache-cache-passe ? Quelle information se cache au d\u00e9but du fichier cache-cache-passe ? Quelle information se cache un peu apr\u00e8s le d\u00e9but du fichier cache-cache-passe ? Quelle information se cache vers le milieu du fichier cache-cache-passe ? Vous ne trouvez pas les informations ? Essayez avec les commandes cat , head et less . 5. Trouver des fichiers \u2693\ufe0e Vous avez l'habitude, maintenant : bash 05_start . Il arrive souvent qu'on ait besoin de retrouver un fichier sur son disque. Deux commandes sont bien pratiques en pareille situation. La commande locate qui n'est pas install\u00e9e sur CoCalc utilise une base de donn\u00e9es des fichiers sur disque et permet de retrouver tr\u00e8s rapidement un fichier par son nom. Le d\u00e9faut est qu'il faut que le fichier soit l\u00e0 depuis assez longtemps pour qu'il ait \u00e9t\u00e9 index\u00e9 dans la base. Mais si vous cherchez un fichier dont vous connaissez une partie du nom sans savoir du tout o\u00f9 il se trouve, cette commande est faite pour vous. La commande find qui elle, en revanche, est install\u00e9e sur CoCalc, permet de fouiller le disque de fa\u00e7on bien plus approfondie. Par exemple, la commande find ddd -name \"pas-la\" cherche dans le r\u00e9pertoire ddd un fichier dont le nom est \"pas-la\" (il y en a un, juste pour l'exemple). But de l'exercice \u2693\ufe0e La commande find offre de nombreuses autres possibilit\u00e9s, que vous pourrez d\u00e9couvrir en lisant la documentation avec man find . Cela vous permettra de r\u00e9pondre aux questions suivantes. Comme pr\u00e9c\u00e9demment, pas question de retaper la ligne de commande en entier \u00e0 chaque tentative. Soyez fain\u00e9ants. Utilisez l'historique des commandes. Les informaticiens sont de grands fain\u00e9ants pr\u00eats \u00e0 tout pour faire travailler l'ordinateur \u00e0 leur place. Dans aaa \u2693\ufe0e Un fichier nomm\u00e9 'ici' se cache quelque part dans le r\u00e9pertoire 'aaa', mais la commande tree n'aide pas beaucoup. Il va falloir utiliser find ! Que contient ce fichier 'ici'? Dans bbb \u2693\ufe0e Cette fois, on ne conna\u00eet m\u00eame pas le nom du fichier. On sait juste que c'est un fichier, et que le pr\u00e9dicat -type de find peut nous aider. Notez que pour chercher dans le manuel, il faut appuyer sur la touche / apr\u00e8s l'avoir ouvert avec man find . Tapez ensuite la cha\u00eene \u00e0 chercher (par exemple -type ) et entr\u00e9e. On saute \u00e0 l'occurrence suivante avec N (pr\u00e9c\u00e9dente avec Shift + N ), et on quitte le manuel avec Q . Dans ccc \u2693\ufe0e Il y a maintenant une multitude de fichiers, et on cherche celui dont la taille est sup\u00e9rieure \u00e0 z\u00e9ro. Les pr\u00e9dicats -size ou -empty vont probablement nous rendre service, ainsi que les connecteurs logiques -and , -or ou -not , \u00e0 vous de voir... Que contient le fichier cach\u00e9 dans 'ccc'? Dans ddd \u2693\ufe0e Cette fois, il y a une multitude de fichiers, et il faut utiliser celui modifi\u00e9 plus r\u00e9cemment que le fichier timestamp plac\u00e9 \u00e0 la racine de EXO . Notez que c'est bien la date de derni\u00e8re modification qui compte. Que contient le fichier cach\u00e9 dans 'ddd'? 6. Fouiller des fichiers \u2693\ufe0e ... La commande find est tr\u00e8s pratique pour trouver un fichier d'apr\u00e8s son nom ou ses attributs de fichier, mais elle ne permet pas d'ouvrir les fichiers \u00e0 la recherche d'un contenu particulier. C'est l'un des multiples services que la commande grep peut rendre. Grep permet de chercher efficacement un texte donn\u00e9 dans des fichiers ou des flux de donn\u00e9es. Cet outil est install\u00e9 sur tous les Unix de la terre, et il existe des versions pour Windows. Tout les utilisateurs du terminal utilisent grep de temps \u00e0 autres. Allez, un petit bash 06_start pour la route... Voici un exemple : grep xeruti aa/* cherche la cha\u00eene xeruti dans tous les fichiers du r\u00e9pertoire aa/ . Chaque fois que cette cha\u00eene est trouv\u00e9e, grep \u00e9crit le nom du fichier o\u00f9 il l'a trouv\u00e9 s\u00e9par\u00e9 par ':' de la ligne compl\u00e8te contenant la cha\u00eene. Mais grep est bien plus puissant que cela. Il permet de chercher non seulement des mots, mais \u00e9galement des motifs avanc\u00e9s comme \"un i suivi d'un nombre pair de t (ou bien d'un nombre impair de s), mais uniquement si c'est en d\u00e9but de ligne\". En informatique, ces motifs s'appellent des expressions r\u00e9guli\u00e8res ( regular expression ou regex en anglais), et c'est d'ailleurs de l\u00e0 que vient le nom de grep: Global Regular Expression Print (affichage d'expressions r\u00e9guli\u00e8res globales). La syntaxe des expressions r\u00e9guli\u00e8res fleure bon les ann\u00e9es 70 (en informatique, cela veut dire que c'est affreusement pr\u00e9historique), mais la puissance de la chose vaut bien la peine qu'on apprenne un peu \u00e0 s'en servir. En cas de probl\u00e8me, on trouve m\u00eame des assistants \u00e0 l'\u00e9criture de regex sur internet. Vous devez maintenant utiliser la commande grep pour trouver des informations dans le r\u00e9pertoire de l'exercice. La page de manuel de grep n'est pas tr\u00e8s utile car elle n'est absolument pas p\u00e9dagogique (c'est un guide de r\u00e9f\u00e9rence), et elle ne donne m\u00eame pas l'int\u00e9gralit\u00e9 de la syntaxe. Pr\u00e9f\u00e9rez la page wikip\u00e9dia . Chercher un mot \u2693\ufe0e On trouve 243 fichiers aux noms parfaitement inint\u00e9ressants dans le r\u00e9pertoire aa . L'un d'entre eux contient la cha\u00eene 'ici'. Utilisez grep pour trouver lequel. Quel est le mot \u00e9trange sur une ligne contenant 'ici' dans 'aa' ? Limiter aux mots d\u00e9butant la ligne \u2693\ufe0e Cette fois, dans le r\u00e9pertoire bb , 'ici' est dans deux fichiers et il faut s\u00e9lectionner la ligne o\u00f9 le motif est plac\u00e9 en d\u00e9but de ligne. Bien s\u00fbr, vous pouvez grepper 'ici' sans sp\u00e9cifier et choisir \u00e0 la main lequel des deux recopier. Mais rien ne sert de tricher ici: ce n'est pas \u00e9valu\u00e9. Il vaut mieux chercher la regex magique s\u00e9lectionnant directement la bonne ligne (relisez wikipedia au besoin). Quel est le mot \u00e9trange sur une ligne d\u00e9butant par 'ici' dans 'bb' ? Ignorer la casse \u2693\ufe0e Cette fois, dans le r\u00e9pertoire cc , on cherche \"plutot\" sans accent, mais on ne sait pas s'il est \u00e9crit en majuscule ou minuscule. Il y a une option pour ignorer la casse, comme indiqu\u00e9 sur la page man de grep ( man grep ) ou dans le message d'aide du programme ( grep --help ). Quel est le mot \u00e9trange sur une ligne contenant 'plutot' dans 'cc' ? R\u00e9p\u00e9ter un motif \u2693\ufe0e Comme indiqu\u00e9 sur wikip\u00e9dia, on utilise des accolades pour indiquer des r\u00e9p\u00e9titions de motif. Mais grep demande \u00e0 ce qu'on \u00e9crive \\{ au lieu de { . \u00c0 la fin, la regex pour attraper hiiiiiiiiii sera 'hi\\{10\\}' . N'oubliez pas les guillemets simples: hi\\{10\\} serait d'abord interpr\u00e9t\u00e9 par le shell qui passerait des choses \u00e9tranges \u00e0 grep. L\u00e0 encore, il est plus facile de tricher que de trouver la bonne regex. Soyez fort, persistez ! Quel est le mot sur une ligne contenant entre 3 et 7 'a' cons\u00e9cutifs dans 'dd' ? Classes de caract\u00e8res \u2693\ufe0e On cherche un mot contenant trois voyelles successives, suivies de quelque chose qui n'est pas un chiffre. On est oblig\u00e9 de d\u00e9crire les voyelles en extension (il s'agit de l'une des lettres suivantes: aeoiu ), mais on peut d\u00e9crire les chiffres en intension (un caract\u00e8re entre 0 et 9 ). En grep, il faut bien \u00e9crire [ et non \\[ . Mais c'est toujours une bonne id\u00e9e de prot\u00e9ger ses expressions r\u00e9guli\u00e8res du shell avec des guillemets simples. Quel est le mot sur une ligne contenant trois voyelles cons\u00e9cutives, non suivies d'un chiffre dans 'ee' ? 7. Encha\u00eenements de commandes \u2693\ufe0e Jusqu'\u00e0 pr\u00e9sent, nous avons utilis\u00e9 le terminal pour lancer des programmes les uns apr\u00e8s les autres, mais \u00e7a n'allait pas tr\u00e8s loin car ces programmes \u00e9taient tr\u00e8s simples. La puissance du shell ne vient pas d'outils de plus en plus perfectionn\u00e9s, mais plut\u00f4t de la facilit\u00e9 avec laquelle on peut combiner des programmes simples pour faire des outils parfaitement adapt\u00e9s \u00e0 la situation actuelle. Le plus souvent, on ne fait m\u00eame pas un script \u00e0 proprement parler, mais on combine plusieurs programmes sur la m\u00eame ligne de commande. On peut par exemple recompiler un programme, l'ex\u00e9cuter sur plusieurs fichiers, v\u00e9rifier que tout s'est bien pass\u00e9 puis effacer les fichiers temporaires. Le tout en une seule commande, accessible simplement avec fl\u00e8che vers le haut. On trouve m\u00eame ici et l\u00e0 des collections de ligne de commandes shell d'une seule ligne (on appelle \u00e7a des one-liners ). Certaines sont pratiques, d'autres au mieux anecdotiques. Ces lignes sont parfois tr\u00e8s longues, et toutes sont difficiles \u00e0 relire et \u00e0 comprendre. D'ailleurs, on n'apprend pas des one-liners par c\u0153ur, on les reconstruit quand on en a besoin. Voyons maintenant comment faire. Combiner des programmes \u2693\ufe0e Pour ex\u00e9cuter deux commandes \u00e0 la suite, il suffit de les s\u00e9parer par ; touch temporaire; ls temporaire; rm temporaire va cr\u00e9er un fichier vide, afficher son nom puis le supprimer. Parfois, on ne veut lancer la seconde commande que si la premi\u00e8re s'est bien pass\u00e9e. Pour cela, il faut \u00e9crire && (lu \"ET\" logique) entre les deux commandes. Comparez le r\u00e9sultat de ls OK && echo \"le fichier existe\" et celui de ls GaBuZoMeu && echo \"le fichier existe\" , sachant que le premier existe mais pas le second. \u00c0 l'inverse, on peut vouloir ne lancer la seconde commande que si la premi\u00e8re a \u00e9chou\u00e9 avec un OU logique. ls OK || echo \"PROBL\u00c8ME!\" ou ls GaBuZoMeu || echo \"PROBL\u00c8ME!\" On peut m\u00eame grouper des commandes avec des parenth\u00e8ses: l'ensemble s'est bien pass\u00e9 si la derni\u00e8re se passe bien. ( ls GaBuZoMeu ; ls OK ) && echo \"le (dernier) fichier existe\" Note pour les plus courageux: les commandes entre parenth\u00e8ses s'ex\u00e9cutent dans un autre contexte, donc (cd /) ne change pas le r\u00e9pertoire courant, seulement celui du contexte entre parenth\u00e8ses. Demandez \u00e0 pwd (print working directory) ainsi si vous n'y croyez pas: (cd / ; echo \"chang\u00e9:\"; pwd) ; echo \"pas chang\u00e9:\" ; pwd Rediriger l'entr\u00e9e et la sortie \u2693\ufe0e Il est tr\u00e8s facile de capturer les affichages d'un programme dans un fichier. Par exemple date > sortie place l'affichage de la commande \u00e0 gauche du > dans un fichier nomm\u00e9 sortie (voir le contenu du fichier: cat sortie ). Le symbole > ne devrait pas se lire \"plus grand\" mais plut\u00f4t \"vers\", comme une fl\u00e8che: l'affichage du programme \u00e0 gauche est redirig\u00e9 dans le fichier \u00e0 droite. Si on r\u00e9ex\u00e9cute la premi\u00e8re commande date > sortie , le contenu du fichier sortie est r\u00e9\u00e9crit. On peut ajouter \u00e0 la fin du fichier au lieu de le remplacer de la fa\u00e7on suivante : date >> sortie . On peut \u00e9galement faire le contraire, et demander \u00e0 un programme de lire son entr\u00e9e dans un fichier. Par exemple, ce r\u00e9pertoire compte un petit script permettant de calculer la somme de deux nombres. Essayez-le: ./plus.sh (l'extension sh signifie qu'il est \u00e9crit en shell). Au lieu de lire depuis le clavier, on peut faire en sorte que ce script lise depuis un fichier. echo 4 6 > fichier permet de cr\u00e9er le fichier tandis que ./plus.sh < fichier lance le script en redirigeant son entr\u00e9e standard depuis le fichier. On peut m\u00eame rediriger \u00e0 la fois l'entr\u00e9e et la sortie d'un programme de la fa\u00e7on suivante: ./plus.sh < fichier > sortie Les redirections peuvent \u00e9galement \u00eatre utilis\u00e9e pour faire taire un programme un peu trop bavard. Par exemple ls -lR /usr demande \u00e0 afficher la liste de beaucoup des fichiers du disque. C'est beaucoup, et vous voulez probablement faire Ctrl-C pour l'interrompre avant la fin. Mais si vous faites ls -lR /usr > sortie , vous ne voyez plus tout cet affichage aga\u00e7ant. Si vous voulez juste faire dispara\u00eetre l'affichage sans le sauvegarder sur disque, redirigez la sortie vers le fichier /dev/null qui est une sorte de trou noir o\u00f9 tout ce qui est \u00e9crit est perdu. Mais si vous faites ls GaBuZoMeu > /dev/null ou echo bla bla > fichier ; ./plus.sh < fichier , vous verrez quand m\u00eame le message d'erreur s'afficher. Comment ce message a-t-il r\u00e9ussi \u00e0 s'\u00e9chapper du trou noir ? C'est qu'en fait, tous les programmes ont deux flux de sortie sur lesquels ils peuvent \u00e9crire: la sortie standard (nomm\u00e9e stdout ) est celle par d\u00e9faut. Le symbole > ne redirige que stdout sans toucher \u00e0 la sortie d'erreur (nomm\u00e9e stderr ), qui continue donc \u00e0 atterrir sur l'\u00e9cran. Cela permet aux programmes d'indiquer leurs probl\u00e8mes m\u00eame quand on a redirig\u00e9 leur sortie standard. Si on le souhaite, on peut rediriger stderr avec 2> : ls GaBuZoMeu 2> erreur (inspectez le fichier produit: cat erreur ). On peut enfin demander \u00e0 rediriger stderr dans stdout avec 2>&1 (le flux 2 -- stderr -- va dans le flux 1 -- stdout). Et bien entendu, on peut rediriger l'entr\u00e9e standard et les deux sorties tout en combinant des s\u00e9quences d'op\u00e9rations. La ligne devient un peu longue, mais \u00e7a ne pose pas de probl\u00e8me. ls GaBuZoMeu 2> /dev/null && echo \"Le fichier existe\" || echo \"PROBL\u00c8ME!\" ls OK 2>&1 >/dev/null && (echo \"Le fichier existe. Son contenu:\"; cat < OK) || echo \"PROBL\u00c8ME!\" Oui, le r\u00e9sultat final n'est ni tr\u00e8s lisible ni m\u00eame tr\u00e8s utile, mais c'est un exemple de commande qu'on construit peu \u00e0 peu lors d'une session de travail, pour r\u00e9pondre \u00e0 un besoin imm\u00e9diat. Prenez cependant le temps de comprendre ce qu'il contient et comment les morceaux sont combin\u00e9s. Tuber des programmes \u2693\ufe0e Faire echo 4 > fichier; echo 6 >> fichier ; ./plus.sh < fichier devient vite fastidieux, et en plus \u00e7a laisse un fichier sur disque. On peut faire mieux en branchant directement la sortie d'un programme sur l'entr\u00e9e d'un autre, avec le symbole | . On le lit \"tube\" ou \"pipe\" en anglais, et on l'obtient sur un clavier fran\u00e7ais en faisant AltGr+6 . L'exemple ci-dessus devient echo 4 6 | ./plus.sh , tout simplement. Et on peut encha\u00eener les commandes presque \u00e0 l'infini: Avec echo 4 6 | ./plus.sh | grep [0-9] , le grep final filtre les lignes contenant au moins un chiffre, c'est-\u00e0-dire celle de r\u00e9sultat. Attention! | et > sont TR\u00c8S diff\u00e9rents. Le premier redirige la sortie d'un programme dans un autre, tandis que le second \u00e9crit dans un fichier. Ex\u00e9cuter echo 4 6 > ./plus.sh serait une TR\u00c8S mauvaise id\u00e9e puisque \u00e7a \u00e9crirait 4 6 \u00e0 la place du script ./plus.sh . Avec | vous essayez de parler au programme \u00e0 droite. Avec > vous tentez de l'effacer en lui \u00e9crivant dessus... Ex 7.1 \u2693\ufe0e Le fichier animaux contient une liste d'animaux, mais avec des doublons. On voudrait utiliser la commande uniq pour retirer les lignes en doublon, puis \u00e9crire le r\u00e9sultat dans un fichier animaux.ok . Mais malheureusement, uniq ne supprime que les doublons que s'il s'agit de lignes cons\u00e9cutives dans le flux. Il faudra donc utiliser la commande sort pour trier les animaux avant de supprimer les doublons. Ex 7.2 \u2693\ufe0e On voudrait constituer un fichier nomm\u00e9 ligne33 contenant exactement la ligne 33 du fichier animaux.ok . Indication: vous aurez besoin des commandes head et tail . Quand on ne leur pr\u00e9cise pas le fichier \u00e0 lire, ces commandes lisent leur entr\u00e9e standard. Par d\u00e9faut, head affiche les 10 premi\u00e8res lignes de ce qu'il lit tandis que tail en affiche les 10 derni\u00e8res lignes. Regardez dans le manuel comment changer le nombre de lignes affich\u00e9es. Ex 7.3 \u2693\ufe0e Combien d'animaux de la liste de d\u00e9part (pas animaux.ok) ont 3 voyelles successives dans leur nom? Indication: utilisez grep , uniq et sort , ainsi que la commande wc -l qui compte le nombre de lignes de son entr\u00e9e standard. Que contient le fichier cach\u00e9 dans 'bbb'?","title":"Activit\u00e9 : initiation au shell linux"},{"location":"nsi1/initiation_au_shell_linux/activite.html#initiation-au-shell-linux","text":"Cette activit\u00e9 est bas\u00e9e sur un travail original de Martin Quinson","title":"Initiation au shell Linux"},{"location":"nsi1/initiation_au_shell_linux/activite.html#petit-tutoriel","text":"Comme les autres syst\u00e8mes d'exploitation, Linux range les fichiers dans une arborescence de r\u00e9pertoires. Voici quelques commandes utiles. Tapez-les une \u00e0 une pour constater le r\u00e9sultat. #!bashpwd savoir o\u00f9 on est sur le disque (Print Working Directory)","title":"Petit tutoriel"},{"location":"nsi1/initiation_au_shell_linux/activite.html#bashmkdir-machin-creer-un-nouveau-repertoire-nomme-machin","text":"ls lister les fichiers et r\u00e9pertoires du r\u00e9pertoire courant cd machin entrer dans le r\u00e9pertoire machin (Change Directory) pwd cd .. aller dans le r\u00e9pertoire \"..\", c'est-\u00e0-dire un \u00e9tage plus haut pwd touch bidule cr\u00e9er un fichier vide nomm\u00e9 bidule (ou change sa date d'acc\u00e8s si le fichier existe) ls rm bidule effacer le fichier bidule. Attention, c'est une op\u00e9ration irr\u00e9versible. ls rmdir machin effacer le r\u00e9pertoire machin (il faut qu'il soit vide). On peut aussi utiliser rm -r machin pour effacer r\u00e9cursivement machin et tout son contenu. ls clear permet d'effacer l'\u00e9cran pour nettoyer. Au besoin, lisez la documentation de ces commandes avec par exemple man ls ( Q pour quiter cette aide). Sachez aussi que : les touches Up et Down du clavier permettent de naviguer dans l'historique des commandes d\u00e9j\u00e0 tap\u00e9es la touche Tab (tabulation) permet de compl\u00e9ter un nom de fichier","title":"!bashmkdir machin` cr\u00e9er un nouveau r\u00e9pertoire nomm\u00e9 machin"},{"location":"nsi1/initiation_au_shell_linux/activite.html#1-creer-des-arborescences","text":"Il s'agit maintenant de cr\u00e9er l'aborescence suivante. \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 dir1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 dir2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 doc1 \u2514\u2500\u2500 \ud83d\udcc1 dir3 \u2514\u2500\u2500 \ud83d\uddb9 doc2 Les logos sont juste l\u00e0 pour l'explication, les noms de fichiers et r\u00e9pertoires ne doivent contenir que des lettres et des chiffres dans cet exercice. Le r\u00e9pertoire au sommet est l'endroit o\u00f9 commence l'exercice, not\u00e9 EXO . Pour commencer l'exercice, dans le terminal, entrez bash 01_start Coinc\u00e9? Utilisez la commande ls -R pour afficher r\u00e9cursivement le contenu de tous les r\u00e9pertoires. Si c'est plus grave, tapez cd pour revenir au r\u00e9pertoire de d\u00e9part et bash 01_start pour tout recommencer. Lorsque vous avez termin\u00e9, tapez bash 01_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant.","title":"1. Cr\u00e9er des arborescences"},{"location":"nsi1/initiation_au_shell_linux/activite.html#2-renommer-et-deplacer","text":"Nous avons vu quelques commandes pour se d\u00e9placer sur le disque et pour cr\u00e9er des fichiers et r\u00e9pertoires. Pour ne pas les oublier, imprimez le pense-b\u00eate du shell . Dans cet exercice, nous allons apprendre \u00e0 d\u00e9placer des fichiers.","title":"2. Renommer et d\u00e9placer"},{"location":"nsi1/initiation_au_shell_linux/activite.html#petit-tutoriel_1","text":"Pour commencer, dans le terminal, entrez bash 02_start Utilisez la commande tree pour voir la situation initiale. La commande mv permet de d\u00e9placer (MoVe) des fichiers et r\u00e9pertoires. Sa syntaxe est tr\u00e8s facile : De base, mv toto bidule permet de renommer le fichier toto en bidule . Cela marche aussi si toto est un r\u00e9pertoire. V\u00e9rifiez le r\u00e9sultat avec la commande tree . Si le second param\u00e8tre de la commande mv existe, \u00e7a doit \u00eatre un r\u00e9pertoire dans lequel le premier param\u00e8tre est d\u00e9plac\u00e9. Par exemple mv bidule dir1 d\u00e9place le fichier bidule dans le r\u00e9pertoire dir1 . V\u00e9rifiez l'\u00e9tat courant avec tree ou ls -R (listing r\u00e9cursif). Enfin, si vous passez plus de deux param\u00e8tres \u00e0 la commande mv , tous ceux du d\u00e9but de la ligne sont d\u00e9plac\u00e9s dans le r\u00e9pertoire indiqu\u00e9 en dernier param\u00e8tre. Par exemple mv machin dir1/bidule truc d\u00e9place les fichiers machin et dir1/bidule (c'est-\u00e0-dire le fichier bidule plac\u00e9 dans dir1 ) dans le r\u00e9pertoire truc . V\u00e9rifiez l'\u00e9tat actuel avec tree . La commande mv , comme beaucoup d'autres, accepte beaucoup de param\u00e8tres int\u00e9ressants. Par exemple mv -i [ param\u00e8tres habituels ] passe en mode interactif : vous devez confirmer chaque op\u00e9ration qui \u00e9crase un fichier existant. Consultez le manuel de cette commande en tapant man mv .","title":"Petit tutoriel"},{"location":"nsi1/initiation_au_shell_linux/activite.html#au-travail","text":"Si vous avez bien suivi le tutoriel, votre arborescence devrait \u00eatre la suivante: \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 dir1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 dir2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 doc1 \u2514\u2500\u2500 \ud83d\udcc1 dir3 \u2514\u2500\u2500 \ud83d\uddb9 doc2 L'objectif est de renommer tous les \u00e9l\u00e9ments pour les mettre en majuscule, comme suit. Il n'est pas possible de juste recr\u00e9er l'arborescence, car le contenu des fichiers doc1 et doc2 doit \u00eatre pr\u00e9serv\u00e9. \ud83d\udcc1 EXO \u251c\u2500\u2500 \ud83d\udcc1 DIR1 \u2502 \u2514\u2500\u2500 \ud83d\udcc1 DIR2 \u2502 \u2514\u2500\u2500 \ud83d\uddb9 DOC1 \u2514\u2500\u2500 \ud83d\udcc1 DIR3 \u2514\u2500\u2500 \ud83d\uddb9 DOC2 Coinc\u00e9? Utilisez la commande tree pour afficher r\u00e9cursivement le contenu de tous les r\u00e9pertoires. Si c'est plus grave, tapez cd pour revenir au r\u00e9pertoire de d\u00e9part et bash 02_start pour tout recommencer. Lorsque vous avez termin\u00e9, tapez bash 02_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant.","title":"Au travail"},{"location":"nsi1/initiation_au_shell_linux/activite.html#3-deplacer-en-masse","text":"Bien. Vous avez compris comment d\u00e9placer des fichiers en shell. Mais avouez que c'est assez r\u00e9barbatif : on irait beaucoup plus vite \u00e0 la souris avec un bon navigateur de fichiers. Alors, \u00e0 quoi bon utiliser le shell ? Eh bien, parce que les op\u00e9rations non triviales vont beaucoup plus vite \u00e0 r\u00e9aliser en shell ! Dans le terminal, entrez bash 03_start . Affichez le contenu du r\u00e9pertoire EXO . C'est le bazar, non ? Heureusement pour vous, la commande mv *.html web va d\u00e9placer tous les fichiers dont le nom termine par .html dans le r\u00e9pertoire web (et seulement ceux-l\u00e0). \u00c0 la souris, il serait fastidieux de devoir les s\u00e9lectionner les uns apr\u00e8s les autres. Dans cet exercice, il vous est demand\u00e9 de d\u00e9placer tous les fichiers html dans le r\u00e9pertoire web , les fichiers pdf dans le r\u00e9pertoire print (que vous devez cr\u00e9er) et les fichiers png dans le r\u00e9pertoire image . Avouez que pouvoir d\u00e9placer autant de fichiers en une seule commande est tout de m\u00eame agr\u00e9able, non ? Pour (re)commencer l'exercice, dans le terminal, entrez bash 03_start . Lorsque vous avez termin\u00e9, tapez bash 03_verif pour v\u00e9rifier et passer \u00e0 l'exercice suivant.","title":"3. D\u00e9placer en masse"},{"location":"nsi1/initiation_au_shell_linux/activite.html#4-lire-le-contenu-des-fichiers","text":"Commencez donc par un petit bash 04_start . Il existe de nombreuses commandes pour afficher le contenu des fichiers \u00e0 l'\u00e9cran. La plus simple est cat fichier , qui affiche le contenu du fichier sur la console. Si on affiche un fichier contenant non pas du texte mais du binaire, on peut avoir des r\u00e9sultats surprenants: cat fichier-binaire affiche un fichier peu intelligible en l'\u00e9tat. Si votre terminal est ... d\u00e9rang\u00e9 apr\u00e8s un tel affichage, il suffit de taper reset pour tout r\u00e9initialiser. Si le fichier est plus long, cette m\u00e9thode permet assez facilement de voir la fin du contenu. C'est d\u00e9j\u00e0 \u00e7a. Par exemple, cat fichier_long risque de vous remplir l'\u00e9cran. Et si on demande \u00e0 afficher un programme binaire, c'est long ET illisible \u00e0 priori: cat /bin/cat affiche le programme cat lui-m\u00eame. Si on veut voir le d\u00e9but d'un fichier, on peut utiliser la commande head fichier_long qui n'affiche que les premi\u00e8res lignes du fichier pass\u00e9. On peut aussi pr\u00e9ciser que l'on veut les 50 premi\u00e8res lignes avec l'option -n : head -n 50 fichier_long De m\u00eame, la commande tail -n 10 fichier_long permet d'afficher les 10 derni\u00e8res lignes d'un fichier long. Enfin, la commande less fichier_long permet de se promener dans l'affichage d'un fichier : la navigation se fait avec les m\u00eames raccourcis que le manuel (le manuel appelle less en interne). Pour rappel : les fl\u00e8ches et page vers le haut/bas permettent de se d\u00e9placer dans le fichier, Q quitte le programme et on voit l'aide avec H .","title":"4. Lire le contenu des fichiers"},{"location":"nsi1/initiation_au_shell_linux/activite.html#but-de-lexercice","text":"Pour passer \u00e0 la suite, il suffit de trouver diff\u00e9rents mots de passe, r\u00e9partis dans diff\u00e9rents fichiers du r\u00e9pertoire. Normalement Ctrl + C ne fonctionne pas dans le terminal et il faut s\u00e9lectionner \u00e0 la souris puis faire Ctrl + Ins pour copier, et Shift + Ins pour coller. Ceci dit, dans CoCalc, les d\u00e9veloppeurs ont eu la bonne id\u00e9e d'autoriser \u00e9galement les bons vieux Ctrl + C pour copier et Ctrl + V pour coller, donc il ne faut pas vous en priver. Bien entendu, il est presque impossible de taper la bonne commande, juste du premier coup. On pourrait la copier/coller depuis juste au dessus avec Ctrl + Ins et Shift + Ins , mais ce serait affreusement lent et frustrant. Il y a bien mieux : on peut retrouver les commandes qu'on vient d'\u00e9crire simplement avec les fl\u00e8ches haut/bas et les modifier. En fait, le terminal est un truc de fain\u00e9ants o\u00f9 tout est fait pour vous simplifier la vie, vous allez voir. Vous avez la flemme de chercher manuellement dans l'historique la ligne o\u00f9 vous utilisez head ? Tapez simplement Ctrl + R pour passer en mode recherche, et \u00e9crivez head . Le shell va fouiller l'historique pour vous. Appuyez sur Entr\u00e9e quand vous l'avez trouv\u00e9. Essayez aussi d'utiliser les fl\u00e8ches pendant/apr\u00e8s la recherche ou de refaire Ctrl + R en cours de recherche: c'est assez bien fait. Quel est le contenu du fichier mot-de-passe ? Quelle information se cache \u00e0 la fin du fichier cache-cache-passe ? Quelle information se cache au d\u00e9but du fichier cache-cache-passe ? Quelle information se cache un peu apr\u00e8s le d\u00e9but du fichier cache-cache-passe ? Quelle information se cache vers le milieu du fichier cache-cache-passe ? Vous ne trouvez pas les informations ? Essayez avec les commandes cat , head et less .","title":"But de l'exercice"},{"location":"nsi1/initiation_au_shell_linux/activite.html#5-trouver-des-fichiers","text":"Vous avez l'habitude, maintenant : bash 05_start . Il arrive souvent qu'on ait besoin de retrouver un fichier sur son disque. Deux commandes sont bien pratiques en pareille situation. La commande locate qui n'est pas install\u00e9e sur CoCalc utilise une base de donn\u00e9es des fichiers sur disque et permet de retrouver tr\u00e8s rapidement un fichier par son nom. Le d\u00e9faut est qu'il faut que le fichier soit l\u00e0 depuis assez longtemps pour qu'il ait \u00e9t\u00e9 index\u00e9 dans la base. Mais si vous cherchez un fichier dont vous connaissez une partie du nom sans savoir du tout o\u00f9 il se trouve, cette commande est faite pour vous. La commande find qui elle, en revanche, est install\u00e9e sur CoCalc, permet de fouiller le disque de fa\u00e7on bien plus approfondie. Par exemple, la commande find ddd -name \"pas-la\" cherche dans le r\u00e9pertoire ddd un fichier dont le nom est \"pas-la\" (il y en a un, juste pour l'exemple).","title":"5. Trouver des fichiers"},{"location":"nsi1/initiation_au_shell_linux/activite.html#but-de-lexercice_1","text":"La commande find offre de nombreuses autres possibilit\u00e9s, que vous pourrez d\u00e9couvrir en lisant la documentation avec man find . Cela vous permettra de r\u00e9pondre aux questions suivantes. Comme pr\u00e9c\u00e9demment, pas question de retaper la ligne de commande en entier \u00e0 chaque tentative. Soyez fain\u00e9ants. Utilisez l'historique des commandes. Les informaticiens sont de grands fain\u00e9ants pr\u00eats \u00e0 tout pour faire travailler l'ordinateur \u00e0 leur place.","title":"But de l'exercice"},{"location":"nsi1/initiation_au_shell_linux/activite.html#6-fouiller-des-fichiers","text":"... La commande find est tr\u00e8s pratique pour trouver un fichier d'apr\u00e8s son nom ou ses attributs de fichier, mais elle ne permet pas d'ouvrir les fichiers \u00e0 la recherche d'un contenu particulier. C'est l'un des multiples services que la commande grep peut rendre. Grep permet de chercher efficacement un texte donn\u00e9 dans des fichiers ou des flux de donn\u00e9es. Cet outil est install\u00e9 sur tous les Unix de la terre, et il existe des versions pour Windows. Tout les utilisateurs du terminal utilisent grep de temps \u00e0 autres. Allez, un petit bash 06_start pour la route... Voici un exemple : grep xeruti aa/* cherche la cha\u00eene xeruti dans tous les fichiers du r\u00e9pertoire aa/ . Chaque fois que cette cha\u00eene est trouv\u00e9e, grep \u00e9crit le nom du fichier o\u00f9 il l'a trouv\u00e9 s\u00e9par\u00e9 par ':' de la ligne compl\u00e8te contenant la cha\u00eene. Mais grep est bien plus puissant que cela. Il permet de chercher non seulement des mots, mais \u00e9galement des motifs avanc\u00e9s comme \"un i suivi d'un nombre pair de t (ou bien d'un nombre impair de s), mais uniquement si c'est en d\u00e9but de ligne\". En informatique, ces motifs s'appellent des expressions r\u00e9guli\u00e8res ( regular expression ou regex en anglais), et c'est d'ailleurs de l\u00e0 que vient le nom de grep: Global Regular Expression Print (affichage d'expressions r\u00e9guli\u00e8res globales). La syntaxe des expressions r\u00e9guli\u00e8res fleure bon les ann\u00e9es 70 (en informatique, cela veut dire que c'est affreusement pr\u00e9historique), mais la puissance de la chose vaut bien la peine qu'on apprenne un peu \u00e0 s'en servir. En cas de probl\u00e8me, on trouve m\u00eame des assistants \u00e0 l'\u00e9criture de regex sur internet. Vous devez maintenant utiliser la commande grep pour trouver des informations dans le r\u00e9pertoire de l'exercice. La page de manuel de grep n'est pas tr\u00e8s utile car elle n'est absolument pas p\u00e9dagogique (c'est un guide de r\u00e9f\u00e9rence), et elle ne donne m\u00eame pas l'int\u00e9gralit\u00e9 de la syntaxe. Pr\u00e9f\u00e9rez la page wikip\u00e9dia .","title":"6. Fouiller des fichiers"},{"location":"nsi1/initiation_au_shell_linux/activite.html#chercher-un-mot","text":"On trouve 243 fichiers aux noms parfaitement inint\u00e9ressants dans le r\u00e9pertoire aa . L'un d'entre eux contient la cha\u00eene 'ici'. Utilisez grep pour trouver lequel. Quel est le mot \u00e9trange sur une ligne contenant 'ici' dans 'aa' ?","title":"Chercher un mot"},{"location":"nsi1/initiation_au_shell_linux/activite.html#limiter-aux-mots-debutant-la-ligne","text":"Cette fois, dans le r\u00e9pertoire bb , 'ici' est dans deux fichiers et il faut s\u00e9lectionner la ligne o\u00f9 le motif est plac\u00e9 en d\u00e9but de ligne. Bien s\u00fbr, vous pouvez grepper 'ici' sans sp\u00e9cifier et choisir \u00e0 la main lequel des deux recopier. Mais rien ne sert de tricher ici: ce n'est pas \u00e9valu\u00e9. Il vaut mieux chercher la regex magique s\u00e9lectionnant directement la bonne ligne (relisez wikipedia au besoin). Quel est le mot \u00e9trange sur une ligne d\u00e9butant par 'ici' dans 'bb' ?","title":"Limiter aux mots d\u00e9butant la ligne"},{"location":"nsi1/initiation_au_shell_linux/activite.html#ignorer-la-casse","text":"Cette fois, dans le r\u00e9pertoire cc , on cherche \"plutot\" sans accent, mais on ne sait pas s'il est \u00e9crit en majuscule ou minuscule. Il y a une option pour ignorer la casse, comme indiqu\u00e9 sur la page man de grep ( man grep ) ou dans le message d'aide du programme ( grep --help ). Quel est le mot \u00e9trange sur une ligne contenant 'plutot' dans 'cc' ?","title":"Ignorer la casse"},{"location":"nsi1/initiation_au_shell_linux/activite.html#repeter-un-motif","text":"Comme indiqu\u00e9 sur wikip\u00e9dia, on utilise des accolades pour indiquer des r\u00e9p\u00e9titions de motif. Mais grep demande \u00e0 ce qu'on \u00e9crive \\{ au lieu de { . \u00c0 la fin, la regex pour attraper hiiiiiiiiii sera 'hi\\{10\\}' . N'oubliez pas les guillemets simples: hi\\{10\\} serait d'abord interpr\u00e9t\u00e9 par le shell qui passerait des choses \u00e9tranges \u00e0 grep. L\u00e0 encore, il est plus facile de tricher que de trouver la bonne regex. Soyez fort, persistez ! Quel est le mot sur une ligne contenant entre 3 et 7 'a' cons\u00e9cutifs dans 'dd' ?","title":"R\u00e9p\u00e9ter un motif"},{"location":"nsi1/initiation_au_shell_linux/activite.html#classes-de-caracteres","text":"On cherche un mot contenant trois voyelles successives, suivies de quelque chose qui n'est pas un chiffre. On est oblig\u00e9 de d\u00e9crire les voyelles en extension (il s'agit de l'une des lettres suivantes: aeoiu ), mais on peut d\u00e9crire les chiffres en intension (un caract\u00e8re entre 0 et 9 ). En grep, il faut bien \u00e9crire [ et non \\[ . Mais c'est toujours une bonne id\u00e9e de prot\u00e9ger ses expressions r\u00e9guli\u00e8res du shell avec des guillemets simples. Quel est le mot sur une ligne contenant trois voyelles cons\u00e9cutives, non suivies d'un chiffre dans 'ee' ?","title":"Classes de caract\u00e8res"},{"location":"nsi1/initiation_au_shell_linux/activite.html#7-enchainements-de-commandes","text":"Jusqu'\u00e0 pr\u00e9sent, nous avons utilis\u00e9 le terminal pour lancer des programmes les uns apr\u00e8s les autres, mais \u00e7a n'allait pas tr\u00e8s loin car ces programmes \u00e9taient tr\u00e8s simples. La puissance du shell ne vient pas d'outils de plus en plus perfectionn\u00e9s, mais plut\u00f4t de la facilit\u00e9 avec laquelle on peut combiner des programmes simples pour faire des outils parfaitement adapt\u00e9s \u00e0 la situation actuelle. Le plus souvent, on ne fait m\u00eame pas un script \u00e0 proprement parler, mais on combine plusieurs programmes sur la m\u00eame ligne de commande. On peut par exemple recompiler un programme, l'ex\u00e9cuter sur plusieurs fichiers, v\u00e9rifier que tout s'est bien pass\u00e9 puis effacer les fichiers temporaires. Le tout en une seule commande, accessible simplement avec fl\u00e8che vers le haut. On trouve m\u00eame ici et l\u00e0 des collections de ligne de commandes shell d'une seule ligne (on appelle \u00e7a des one-liners ). Certaines sont pratiques, d'autres au mieux anecdotiques. Ces lignes sont parfois tr\u00e8s longues, et toutes sont difficiles \u00e0 relire et \u00e0 comprendre. D'ailleurs, on n'apprend pas des one-liners par c\u0153ur, on les reconstruit quand on en a besoin. Voyons maintenant comment faire.","title":"7. Encha\u00eenements de commandes"},{"location":"nsi1/initiation_au_shell_linux/activite.html#combiner-des-programmes","text":"Pour ex\u00e9cuter deux commandes \u00e0 la suite, il suffit de les s\u00e9parer par ; touch temporaire; ls temporaire; rm temporaire va cr\u00e9er un fichier vide, afficher son nom puis le supprimer. Parfois, on ne veut lancer la seconde commande que si la premi\u00e8re s'est bien pass\u00e9e. Pour cela, il faut \u00e9crire && (lu \"ET\" logique) entre les deux commandes. Comparez le r\u00e9sultat de ls OK && echo \"le fichier existe\" et celui de ls GaBuZoMeu && echo \"le fichier existe\" , sachant que le premier existe mais pas le second. \u00c0 l'inverse, on peut vouloir ne lancer la seconde commande que si la premi\u00e8re a \u00e9chou\u00e9 avec un OU logique. ls OK || echo \"PROBL\u00c8ME!\" ou ls GaBuZoMeu || echo \"PROBL\u00c8ME!\" On peut m\u00eame grouper des commandes avec des parenth\u00e8ses: l'ensemble s'est bien pass\u00e9 si la derni\u00e8re se passe bien. ( ls GaBuZoMeu ; ls OK ) && echo \"le (dernier) fichier existe\" Note pour les plus courageux: les commandes entre parenth\u00e8ses s'ex\u00e9cutent dans un autre contexte, donc (cd /) ne change pas le r\u00e9pertoire courant, seulement celui du contexte entre parenth\u00e8ses. Demandez \u00e0 pwd (print working directory) ainsi si vous n'y croyez pas: (cd / ; echo \"chang\u00e9:\"; pwd) ; echo \"pas chang\u00e9:\" ; pwd","title":"Combiner des programmes"},{"location":"nsi1/initiation_au_shell_linux/activite.html#rediriger-lentree-et-la-sortie","text":"Il est tr\u00e8s facile de capturer les affichages d'un programme dans un fichier. Par exemple date > sortie place l'affichage de la commande \u00e0 gauche du > dans un fichier nomm\u00e9 sortie (voir le contenu du fichier: cat sortie ). Le symbole > ne devrait pas se lire \"plus grand\" mais plut\u00f4t \"vers\", comme une fl\u00e8che: l'affichage du programme \u00e0 gauche est redirig\u00e9 dans le fichier \u00e0 droite. Si on r\u00e9ex\u00e9cute la premi\u00e8re commande date > sortie , le contenu du fichier sortie est r\u00e9\u00e9crit. On peut ajouter \u00e0 la fin du fichier au lieu de le remplacer de la fa\u00e7on suivante : date >> sortie . On peut \u00e9galement faire le contraire, et demander \u00e0 un programme de lire son entr\u00e9e dans un fichier. Par exemple, ce r\u00e9pertoire compte un petit script permettant de calculer la somme de deux nombres. Essayez-le: ./plus.sh (l'extension sh signifie qu'il est \u00e9crit en shell). Au lieu de lire depuis le clavier, on peut faire en sorte que ce script lise depuis un fichier. echo 4 6 > fichier permet de cr\u00e9er le fichier tandis que ./plus.sh < fichier lance le script en redirigeant son entr\u00e9e standard depuis le fichier. On peut m\u00eame rediriger \u00e0 la fois l'entr\u00e9e et la sortie d'un programme de la fa\u00e7on suivante: ./plus.sh < fichier > sortie Les redirections peuvent \u00e9galement \u00eatre utilis\u00e9e pour faire taire un programme un peu trop bavard. Par exemple ls -lR /usr demande \u00e0 afficher la liste de beaucoup des fichiers du disque. C'est beaucoup, et vous voulez probablement faire Ctrl-C pour l'interrompre avant la fin. Mais si vous faites ls -lR /usr > sortie , vous ne voyez plus tout cet affichage aga\u00e7ant. Si vous voulez juste faire dispara\u00eetre l'affichage sans le sauvegarder sur disque, redirigez la sortie vers le fichier /dev/null qui est une sorte de trou noir o\u00f9 tout ce qui est \u00e9crit est perdu. Mais si vous faites ls GaBuZoMeu > /dev/null ou echo bla bla > fichier ; ./plus.sh < fichier , vous verrez quand m\u00eame le message d'erreur s'afficher. Comment ce message a-t-il r\u00e9ussi \u00e0 s'\u00e9chapper du trou noir ? C'est qu'en fait, tous les programmes ont deux flux de sortie sur lesquels ils peuvent \u00e9crire: la sortie standard (nomm\u00e9e stdout ) est celle par d\u00e9faut. Le symbole > ne redirige que stdout sans toucher \u00e0 la sortie d'erreur (nomm\u00e9e stderr ), qui continue donc \u00e0 atterrir sur l'\u00e9cran. Cela permet aux programmes d'indiquer leurs probl\u00e8mes m\u00eame quand on a redirig\u00e9 leur sortie standard. Si on le souhaite, on peut rediriger stderr avec 2> : ls GaBuZoMeu 2> erreur (inspectez le fichier produit: cat erreur ). On peut enfin demander \u00e0 rediriger stderr dans stdout avec 2>&1 (le flux 2 -- stderr -- va dans le flux 1 -- stdout). Et bien entendu, on peut rediriger l'entr\u00e9e standard et les deux sorties tout en combinant des s\u00e9quences d'op\u00e9rations. La ligne devient un peu longue, mais \u00e7a ne pose pas de probl\u00e8me. ls GaBuZoMeu 2> /dev/null && echo \"Le fichier existe\" || echo \"PROBL\u00c8ME!\" ls OK 2>&1 >/dev/null && (echo \"Le fichier existe. Son contenu:\"; cat < OK) || echo \"PROBL\u00c8ME!\" Oui, le r\u00e9sultat final n'est ni tr\u00e8s lisible ni m\u00eame tr\u00e8s utile, mais c'est un exemple de commande qu'on construit peu \u00e0 peu lors d'une session de travail, pour r\u00e9pondre \u00e0 un besoin imm\u00e9diat. Prenez cependant le temps de comprendre ce qu'il contient et comment les morceaux sont combin\u00e9s.","title":"Rediriger l'entr\u00e9e et la sortie"},{"location":"nsi1/initiation_au_shell_linux/activite.html#tuber-des-programmes","text":"Faire echo 4 > fichier; echo 6 >> fichier ; ./plus.sh < fichier devient vite fastidieux, et en plus \u00e7a laisse un fichier sur disque. On peut faire mieux en branchant directement la sortie d'un programme sur l'entr\u00e9e d'un autre, avec le symbole | . On le lit \"tube\" ou \"pipe\" en anglais, et on l'obtient sur un clavier fran\u00e7ais en faisant AltGr+6 . L'exemple ci-dessus devient echo 4 6 | ./plus.sh , tout simplement. Et on peut encha\u00eener les commandes presque \u00e0 l'infini: Avec echo 4 6 | ./plus.sh | grep [0-9] , le grep final filtre les lignes contenant au moins un chiffre, c'est-\u00e0-dire celle de r\u00e9sultat. Attention! | et > sont TR\u00c8S diff\u00e9rents. Le premier redirige la sortie d'un programme dans un autre, tandis que le second \u00e9crit dans un fichier. Ex\u00e9cuter echo 4 6 > ./plus.sh serait une TR\u00c8S mauvaise id\u00e9e puisque \u00e7a \u00e9crirait 4 6 \u00e0 la place du script ./plus.sh . Avec | vous essayez de parler au programme \u00e0 droite. Avec > vous tentez de l'effacer en lui \u00e9crivant dessus...","title":"Tuber des programmes"},{"location":"nsi1/initiation_au_shell_linux/activite.html#ex-71","text":"Le fichier animaux contient une liste d'animaux, mais avec des doublons. On voudrait utiliser la commande uniq pour retirer les lignes en doublon, puis \u00e9crire le r\u00e9sultat dans un fichier animaux.ok . Mais malheureusement, uniq ne supprime que les doublons que s'il s'agit de lignes cons\u00e9cutives dans le flux. Il faudra donc utiliser la commande sort pour trier les animaux avant de supprimer les doublons.","title":"Ex 7.1"},{"location":"nsi1/initiation_au_shell_linux/activite.html#ex-72","text":"On voudrait constituer un fichier nomm\u00e9 ligne33 contenant exactement la ligne 33 du fichier animaux.ok . Indication: vous aurez besoin des commandes head et tail . Quand on ne leur pr\u00e9cise pas le fichier \u00e0 lire, ces commandes lisent leur entr\u00e9e standard. Par d\u00e9faut, head affiche les 10 premi\u00e8res lignes de ce qu'il lit tandis que tail en affiche les 10 derni\u00e8res lignes. Regardez dans le manuel comment changer le nombre de lignes affich\u00e9es.","title":"Ex 7.2"},{"location":"nsi1/initiation_au_shell_linux/activite.html#ex-73","text":"Combien d'animaux de la liste de d\u00e9part (pas animaux.ok) ont 3 voyelles successives dans leur nom? Indication: utilisez grep , uniq et sort , ainsi que la commande wc -l qui compte le nombre de lignes de son entr\u00e9e standard. Que contient le fichier cach\u00e9 dans 'bbb'?","title":"Ex 7.3"},{"location":"nsi2/index.html","text":"NSI2 - Informations \u2693\ufe0e 02/06/2021 : Le chapitre 28 a \u00e9t\u00e9 mis \u00e0 jour. 19/05/2021 : Le chapitre 27 est en pr\u00e9paration. 18/05/2021 : Le chapitre 26 a \u00e9t\u00e9 mis \u00e0 jour. 04/05/2021 : Le chapitre 25 a \u00e9t\u00e9 mis \u00e0 jour. 25/04/2021 : Le chapitre 24 a \u00e9t\u00e9 mis \u00e0 jour.","title":"Infos"},{"location":"nsi2/index.html#nsi2-informations","text":"02/06/2021 : Le chapitre 28 a \u00e9t\u00e9 mis \u00e0 jour. 19/05/2021 : Le chapitre 27 est en pr\u00e9paration. 18/05/2021 : Le chapitre 26 a \u00e9t\u00e9 mis \u00e0 jour. 04/05/2021 : Le chapitre 25 a \u00e9t\u00e9 mis \u00e0 jour. 25/04/2021 : Le chapitre 24 a \u00e9t\u00e9 mis \u00e0 jour.","title":"NSI2 - Informations"},{"location":"nsi2/ch24/diviser_pour_regner.html","text":"Diviser pour r\u00e9gner \u2693\ufe0e Un exemple d\u00e9j\u00e0 trait\u00e9 \u2693\ufe0e Nous avons d\u00e9j\u00e0 rencontr\u00e9 des situations o\u00f9 l'on appliquait cette strat\u00e9gie. La plus marquante \u00e9tait sans doute celle des tours de Hano\u00ef dont voici un script de r\u00e9solution : def hanoi ( n : int , depart : str , interm : str , dest : str ) -> None : if n > 0 : hanoi ( n - 1 , depart , dest , interm ) print ( \"D\u00e9placer un palet de\" , depart , \"vers\" , dest ) hanoi ( n - 1 , interm , depart , dest ) L'appel hanoi ( 3 , 'A' , 'B' , 'C' ) affiche D\u00e9placer un palet de A vers C D\u00e9placer un palet de A vers B D\u00e9placer un palet de C vers B D\u00e9placer un palet de A vers C D\u00e9placer un palet de B vers A D\u00e9placer un palet de B vers C D\u00e9placer un palet de A vers C Le principe \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent est caract\u00e9ristique de la strat\u00e9gie \u00abdiviser pour r\u00e9gner\u00bb, qui consiste \u00e0 D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes. Le tri fusion \u2693\ufe0e Principe \u2693\ufe0e Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab\u00e0 peu pr\u00e8s \u00e9gales\u00bb. On trie ces listes en utilisant... le tri fusion. On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. Une chor\u00e9graphie du tri fusion Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. def fusion ( lst1 : list , lst2 : list ) -> list : if not lst1 or not lst2 : # si l'une des listes est vide return lst1 or lst2 # alors on renvoie l'autre else : a , b = lst1 [ 0 ], lst2 [ 0 ] if a < b : # sinon on compare leurs premiers \u00e9l\u00e9ments return [ a ] + fusion ( lst1 [ 1 :], lst2 ) # on place le plus petit en t\u00eate et on fusionne le reste elif b > a : return [ b ] + fusion ( lst1 , lst2 [ 1 :]) else : # dans le cas o\u00f9 les 2 \u00e9l\u00e9ments sont \u00e9gaux on peut les placer tous les deux return [ a , b ] + fusion ( lst1 [ 1 :], lst2 [ 1 :]) Enfin, la fonction tri_fusion . def tri_fusion ( lst : list ) -> list : if len ( lst ) < 2 : # cas d'arr\u00eat return lst lst1 , lst2 = scinde ( lst ) # sinon on scinde return fusion ( tri_fusion ( lst1 ), tri_fusion ( lst2 )) # et on fusionne les sous-listes tri\u00e9es Complexit\u00e9 du tri fusion \u2693\ufe0e Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. En classe de Premi\u00e8re, nous avons \u00e9tudi\u00e9 des algorithmes de tri dits \u00ablents\u00bb, car de complexit\u00e9 quadratique : pour une liste de taille \\(n\\) , le nombre d'op\u00e9rations \u00e9l\u00e9mentaires pour trier ce tableau est \u00abde l'ordre de \\(n^2\\) \u00bb. Ainsi, pour trier une liste de \\(10^6\\) entiers avec le tri par s\u00e9lection (par exemple), le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires est de l'ordre de \\(10^{12}\\) . Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\ln n\\) . \\(\\ln n\\) est le logarithme n\u00e9perien de \\(n\\) mais peut \u00eatre remplac\u00e9 par le logarithme en base 2 ou en base 10 sans changer les ordres de grandeur. Exemple Pour trier une liste de \\(10^6\\) entiers, il faudra de l'ordre de 6 millions d'op\u00e9rations \u00e9l\u00e9mentaires. V\u00e9rification exp\u00e9rimentale On peut v\u00e9rifier ce r\u00e9sultat exp\u00e9rimentalement ici . Rotation d'une image carr\u00e9e d'un quart de tour \u2693\ufe0e On suppose qu'on dispose d'une image carr\u00e9e de c\u00f4t\u00e9 \\(n\\) pixels, o\u00f9 \\(n\\) est une puissance de 2. Pour l'exemple voic une photo (coloris\u00e9e) carr\u00e9e d' Alan Turing de c\u00f4t\u00e9 512 pixels. On aimerait faire subir un quart de tour \u00e0 cette photo (dans le sens antihoraire) en utilisant une strat\u00e9gie de type \u00abdiviser pour r\u00e9gner\u00bb. On va proc\u00e9der ainsi : On partage l'image en 4 carr\u00e9s de c\u00f4t\u00e9 deux fois moindre. On fait tourner ces 4 carr\u00e9s. On fait subir une permutation circulaire aux 4 carr\u00e9s \u00c0 l'\u00e9tape 2, pour faire tourner les 4 carr\u00e9s, on se retrouve avec le m\u00eame probl\u00e8me mais avec des carr\u00e9s de c\u00f4t\u00e9 2 fois plus petits. On r\u00e9p\u00e8te donc le processus jusqu'\u00e0 n'avoir plus que des carr\u00e9s de c\u00f4t\u00e9 1 pixel (sur lesquels il n'y a pas besoin de faire quoi que soit). Voici ce que cela donne Programmation de la rotation d'un quart de tour d'une image carr\u00e9e On peut la retrouver ici . Exercices \u2693\ufe0e Exercice : Recherche dichotomique Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00abdiviser pour r\u00e9gner\u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. Solution Pour savoir si un \u00e9l\u00e9ment appartient \u00e0 la liste, on regarde celui qui est \u00ab\u00e0 peu pr\u00e8s au milieu\u00bb. Si c'est le bon c'est termin\u00e9, sinon on fait de m\u00eame avec la sous-liste des \u00e9l\u00e9ments pr\u00e9c\u00e9dents et avec celle des \u00e9l\u00e9ments suivants. def rech_dicho ( lst , elt ): n = len ( lst ) if n < 2 : return elt in lst elif lst [ n // 2 ] == elt : return True else : return rech_dicho ( lst [: n // 2 ], elt ) if lst [ n // 2 ] > elt else rech_dicho ( lst [ n // 2 + 1 :], elt ) Algorithme de Karatsuba Il s'agit d'un algorithme qui applique la strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb pour effectuer des multiplications de mani\u00e8re efficace. Chercher sur Internet ce qu'est cet algorithme. Programmer cet algorithme en Python. Voir des indices Principe Si \\(x\\) et \\(y\\) s'\u00e9crivent au plus avec \\(2n\\) bits, alors on peut les \u00e9crire \\(\\begin{cases} x &= a\\times 2^n + b\\\\ y &= c\\times 2^n +d\\\\ \\end{cases}\\) , o\u00f9 \\(a\\) , \\(b\\) , \\(c\\) et \\(d\\) s'\u00e9crivent au plus \\(n\\) bits. Mais alors \\(x\\times y = ab2^{2n}+(ac + bd -(a-b)(c-d))2^n+bd\\) . Dans cette \u00e9criture, il y a 3 multiplications \u00e0 faire avec des nombres s'\u00e9crivant avec au plus \\(n\\) bits: \\(ac\\) \\(bd\\) \\((a-b)(c-d)\\) Le reste (additions et multiplication par \\(2^{2n}\\) ou \\(2^n\\) ne prend pas beaucoup de temps \u00e0 faire (les additions sont plus rapides que les multiplications et multiplier un nombre par \\(2^n\\) revient \u00e0 lui ajouter \\(n\\) bits valant 0 \u00e0 droite). La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb vient du fait qu'on calcule ces 3 produits en appliquant de nouveau l'algorithme de Karatsuba. Indice de programmation 1 On peut d\u00e9j\u00e0 code une fonction size qui - en entr\u00e9e prend un int x; - renvoie le nombre de bits de l'\u00e9criture binaire de x. Pour ce faire il suffit de diviser x par 2 (avec // ) jusqu'\u00e0 trouver 0. Indice de programmation 2 Pour multiplier x par \\(2^n\\) on peut utiliser l'op\u00e9rateur << : x << n . Pour diviser, utiliser >> . Ainsi on pourra \u00e9crire a = x >> ( 2 ** n ) b = x % ( 2 ** n ) Et caetera.","title":"CH24 : diviser pour r\u00e9gner"},{"location":"nsi2/ch24/diviser_pour_regner.html#diviser-pour-regner","text":"","title":"Diviser pour r\u00e9gner"},{"location":"nsi2/ch24/diviser_pour_regner.html#un-exemple-deja-traite","text":"Nous avons d\u00e9j\u00e0 rencontr\u00e9 des situations o\u00f9 l'on appliquait cette strat\u00e9gie. La plus marquante \u00e9tait sans doute celle des tours de Hano\u00ef dont voici un script de r\u00e9solution : def hanoi ( n : int , depart : str , interm : str , dest : str ) -> None : if n > 0 : hanoi ( n - 1 , depart , dest , interm ) print ( \"D\u00e9placer un palet de\" , depart , \"vers\" , dest ) hanoi ( n - 1 , interm , depart , dest ) L'appel hanoi ( 3 , 'A' , 'B' , 'C' ) affiche D\u00e9placer un palet de A vers C D\u00e9placer un palet de A vers B D\u00e9placer un palet de C vers B D\u00e9placer un palet de A vers C D\u00e9placer un palet de B vers A D\u00e9placer un palet de B vers C D\u00e9placer un palet de A vers C","title":"Un exemple d\u00e9j\u00e0 trait\u00e9"},{"location":"nsi2/ch24/diviser_pour_regner.html#le-principe","text":"L'exemple pr\u00e9c\u00e9dent est caract\u00e9ristique de la strat\u00e9gie \u00abdiviser pour r\u00e9gner\u00bb, qui consiste \u00e0 D\u00e9composer un probl\u00e8me en un ou plusieurs sous-probl\u00e8mes de m\u00eame nature mais plus petits. R\u00e9soudre les sous-probl\u00e8mes, g\u00e9n\u00e9ralement de mani\u00e8re r\u00e9cursive, jusqu'\u00e0 ce qu'on arrive aux cas d'arr\u00eat : des sous-probl\u00e8mes que l'on sait r\u00e9soudre imm\u00e9diatement. Construire la solution au probl\u00e8me initial \u00e0 partir des solutions des sous-probl\u00e8mes.","title":"Le principe"},{"location":"nsi2/ch24/diviser_pour_regner.html#le-tri-fusion","text":"","title":"Le tri fusion"},{"location":"nsi2/ch24/diviser_pour_regner.html#principe","text":"Voici un deuxi\u00e8me exemple d'application de cette strat\u00e9gie : le tri fusion . On doit cet algorithme \u00e0 John Von Neumann . On dispose d'une liste d'entiers que l'on veut trier dans l'ordre croissant. On scinde cette liste en deux listes de longueurs \u00ab\u00e0 peu pr\u00e8s \u00e9gales\u00bb. On trie ces listes en utilisant... le tri fusion. On fusionne les deux listes tri\u00e9es par ordre croissant pour ne plus en obtenir qu'une. Une chor\u00e9graphie du tri fusion Voici comment coder le tri fusion : On a tout d'abord besoin d'une fonction scinde qui renvoie la premi\u00e8re moiti\u00e9 et la deuxi\u00e8me moiti\u00e9 de la liste qu'on lui passe en argument. def scinde ( lst : list ) -> tuple : return lst [: len ( lst ) // 2 ], lst [ len ( lst ) // 2 :] Ensuite, on a besoin d'une fonction fusion qui, \u00e9tant donn\u00e9e deux listes tri\u00e9es, les fusionne. def fusion ( lst1 : list , lst2 : list ) -> list : if not lst1 or not lst2 : # si l'une des listes est vide return lst1 or lst2 # alors on renvoie l'autre else : a , b = lst1 [ 0 ], lst2 [ 0 ] if a < b : # sinon on compare leurs premiers \u00e9l\u00e9ments return [ a ] + fusion ( lst1 [ 1 :], lst2 ) # on place le plus petit en t\u00eate et on fusionne le reste elif b > a : return [ b ] + fusion ( lst1 , lst2 [ 1 :]) else : # dans le cas o\u00f9 les 2 \u00e9l\u00e9ments sont \u00e9gaux on peut les placer tous les deux return [ a , b ] + fusion ( lst1 [ 1 :], lst2 [ 1 :]) Enfin, la fonction tri_fusion . def tri_fusion ( lst : list ) -> list : if len ( lst ) < 2 : # cas d'arr\u00eat return lst lst1 , lst2 = scinde ( lst ) # sinon on scinde return fusion ( tri_fusion ( lst1 ), tri_fusion ( lst2 )) # et on fusionne les sous-listes tri\u00e9es","title":"Principe"},{"location":"nsi2/ch24/diviser_pour_regner.html#complexite-du-tri-fusion","text":"Notons \\(n\\) la taille de la liste \u00e0 trier et consid\u00e9rons comme seule op\u00e9ration \u00e9l\u00e9mentaire le fait d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une liste. En classe de Premi\u00e8re, nous avons \u00e9tudi\u00e9 des algorithmes de tri dits \u00ablents\u00bb, car de complexit\u00e9 quadratique : pour une liste de taille \\(n\\) , le nombre d'op\u00e9rations \u00e9l\u00e9mentaires pour trier ce tableau est \u00abde l'ordre de \\(n^2\\) \u00bb. Ainsi, pour trier une liste de \\(10^6\\) entiers avec le tri par s\u00e9lection (par exemple), le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires est de l'ordre de \\(10^{12}\\) . Complexit\u00e9 du tri fusion Le nombre d'op\u00e9rations \u00e9l\u00e9mentaires n\u00e9cessaires pour trier une liste de taille \\(n\\) par la m\u00e9thode du tri fusion est de l'ordre de \\(n\\times\\ln n\\) . \\(\\ln n\\) est le logarithme n\u00e9perien de \\(n\\) mais peut \u00eatre remplac\u00e9 par le logarithme en base 2 ou en base 10 sans changer les ordres de grandeur. Exemple Pour trier une liste de \\(10^6\\) entiers, il faudra de l'ordre de 6 millions d'op\u00e9rations \u00e9l\u00e9mentaires. V\u00e9rification exp\u00e9rimentale On peut v\u00e9rifier ce r\u00e9sultat exp\u00e9rimentalement ici .","title":"Complexit\u00e9 du tri fusion"},{"location":"nsi2/ch24/diviser_pour_regner.html#rotation-dune-image-carree-dun-quart-de-tour","text":"On suppose qu'on dispose d'une image carr\u00e9e de c\u00f4t\u00e9 \\(n\\) pixels, o\u00f9 \\(n\\) est une puissance de 2. Pour l'exemple voic une photo (coloris\u00e9e) carr\u00e9e d' Alan Turing de c\u00f4t\u00e9 512 pixels. On aimerait faire subir un quart de tour \u00e0 cette photo (dans le sens antihoraire) en utilisant une strat\u00e9gie de type \u00abdiviser pour r\u00e9gner\u00bb. On va proc\u00e9der ainsi : On partage l'image en 4 carr\u00e9s de c\u00f4t\u00e9 deux fois moindre. On fait tourner ces 4 carr\u00e9s. On fait subir une permutation circulaire aux 4 carr\u00e9s \u00c0 l'\u00e9tape 2, pour faire tourner les 4 carr\u00e9s, on se retrouve avec le m\u00eame probl\u00e8me mais avec des carr\u00e9s de c\u00f4t\u00e9 2 fois plus petits. On r\u00e9p\u00e8te donc le processus jusqu'\u00e0 n'avoir plus que des carr\u00e9s de c\u00f4t\u00e9 1 pixel (sur lesquels il n'y a pas besoin de faire quoi que soit). Voici ce que cela donne Programmation de la rotation d'un quart de tour d'une image carr\u00e9e On peut la retrouver ici .","title":"Rotation d'une image carr\u00e9e d'un quart de tour"},{"location":"nsi2/ch24/diviser_pour_regner.html#exercices","text":"Exercice : Recherche dichotomique Expliquer pourquoi la recherche dichotomique d'un \u00e9l\u00e9ment dans une liste d'entiers tri\u00e9s dans l'ordre croissant peut \u00eatre vue comme un exemple de strat\u00e9gie \u00abdiviser pour r\u00e9gner\u00bb. Programmer la recherche dichotomique de mani\u00e8re r\u00e9cursive. Solution Pour savoir si un \u00e9l\u00e9ment appartient \u00e0 la liste, on regarde celui qui est \u00ab\u00e0 peu pr\u00e8s au milieu\u00bb. Si c'est le bon c'est termin\u00e9, sinon on fait de m\u00eame avec la sous-liste des \u00e9l\u00e9ments pr\u00e9c\u00e9dents et avec celle des \u00e9l\u00e9ments suivants. def rech_dicho ( lst , elt ): n = len ( lst ) if n < 2 : return elt in lst elif lst [ n // 2 ] == elt : return True else : return rech_dicho ( lst [: n // 2 ], elt ) if lst [ n // 2 ] > elt else rech_dicho ( lst [ n // 2 + 1 :], elt ) Algorithme de Karatsuba Il s'agit d'un algorithme qui applique la strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb pour effectuer des multiplications de mani\u00e8re efficace. Chercher sur Internet ce qu'est cet algorithme. Programmer cet algorithme en Python. Voir des indices Principe Si \\(x\\) et \\(y\\) s'\u00e9crivent au plus avec \\(2n\\) bits, alors on peut les \u00e9crire \\(\\begin{cases} x &= a\\times 2^n + b\\\\ y &= c\\times 2^n +d\\\\ \\end{cases}\\) , o\u00f9 \\(a\\) , \\(b\\) , \\(c\\) et \\(d\\) s'\u00e9crivent au plus \\(n\\) bits. Mais alors \\(x\\times y = ab2^{2n}+(ac + bd -(a-b)(c-d))2^n+bd\\) . Dans cette \u00e9criture, il y a 3 multiplications \u00e0 faire avec des nombres s'\u00e9crivant avec au plus \\(n\\) bits: \\(ac\\) \\(bd\\) \\((a-b)(c-d)\\) Le reste (additions et multiplication par \\(2^{2n}\\) ou \\(2^n\\) ne prend pas beaucoup de temps \u00e0 faire (les additions sont plus rapides que les multiplications et multiplier un nombre par \\(2^n\\) revient \u00e0 lui ajouter \\(n\\) bits valant 0 \u00e0 droite). La strat\u00e9gie \u00ab diviser pour r\u00e9gner \u00bb vient du fait qu'on calcule ces 3 produits en appliquant de nouveau l'algorithme de Karatsuba. Indice de programmation 1 On peut d\u00e9j\u00e0 code une fonction size qui - en entr\u00e9e prend un int x; - renvoie le nombre de bits de l'\u00e9criture binaire de x. Pour ce faire il suffit de diviser x par 2 (avec // ) jusqu'\u00e0 trouver 0. Indice de programmation 2 Pour multiplier x par \\(2^n\\) on peut utiliser l'op\u00e9rateur << : x << n . Pour diviser, utiliser >> . Ainsi on pourra \u00e9crire a = x >> ( 2 ** n ) b = x % ( 2 ** n ) Et caetera.","title":"Exercices"},{"location":"nsi2/ch25/programmation_dynamique.html","text":"Programmation dynamique \u2693\ufe0e Un exemple bien connu \u2693\ufe0e Nous commen\u00e7ons \u00e0 bien conna\u00eetre la suite de Fibonacci \\[F_n=\\begin{cases}1 & \\mbox{si } n=0\\mbox{ ou }n=1\\\\ F_{n-1}+F_{n-2} &\\mbox{sinon}\\end{cases}\\] Si on la programme na\u00efvement de mani\u00e8re r\u00e9cursive, voici ce qu'on obtient : def fibo ( n ): if n < 2 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Or, voici l'arbre des appels r\u00e9cursifs lors de l'ex\u00e9cution de fibo(4) : Et pour fibo(5) on obtient : Lors de cet appel, fibo(3) est appel\u00e9e 2 fois, fibo(2) 3 fois, fibo(1) 5 fois et fibo(0) 3 fois ! Il n'est donc pas \u00e9tonnant que fibo(40) prenne quelques secondes. Quant \u00e0 fibo(100) , ce n'est m\u00eame pas la peine d'y penser ! Notre strat\u00e9gie, de type \u00ab diviser pour r\u00e9gner \u00bb, d\u00e9compose le calcul de fibo(n) en 2 calculs plus simples, mais ces probl\u00e8mes ne sont pas ind\u00e9pendants , comme l'illustre le graphe suivant, obtenu \u00e0 partir du sch\u00e9ma pr\u00e9c\u00e9dent. La m\u00e9mo\u00efsation \u2693\ufe0e D\u00e9finition : m\u00e9mo\u00efsation C'est le fait de garder en m\u00e9moire les solutions des sous-probl\u00e8mes pour pouvoir les r\u00e9utiliser sans avoir \u00e0 les d\u00e9terminer de nouveau. Cela veut dire qu'avant de renvoyer un r\u00e9sultat, la fonction le stocke (dans une liste ou un dictionnaire). Ce qui est fort agr\u00e9able, c'est que les listes et les dictionnaires sont de type mutable , ce qui nous permet d'\u00e9crire ceci : solution = [ 1 , 1 ] # on sait que les 2 premiers termes sont 1 def fibo_dyn ( n ): if n >= len ( solution ): # si solution[n] n'existe pas r = fibo_dyn ( n - 1 ) + fibo_dyn ( n - 2 ) # on calcule r\u00e9cursivement solution . append ( r ) # puis on stocke la solution return r # et on la renvoie else : return solution [ n ] # sinon on renvoie la solution d\u00e9j\u00e0 calcul\u00e9e print ( fibo_dyn ( 500 )) Et l\u00e0, on peut calculer rapidement que \\(F_{40}=165\\,580\\,141\\) , et m\u00eame que \\(\\scriptsize F_ {500}=225\\,591\\,516\\,161\\,936\\,330\\,872\\,512\\,695\\,036\\,072\\,072\\,046\\,011\\,324\\,913\\,758\\,190\\,588\\,638\\,866\\,418\\,474\\,627\\,738\\,686\\,883\\,405\\,015\\,987\\,052\\,796\\,968\\,498\\,626\\) Le fait d'utiliser la m\u00e9mo\u00efsation rend les choses bien plus rapides ! Exercice : programmation dynamique de la suite de Fibonacci En s'inspirant du script pr\u00e9c\u00e9dent, \u00e9crire la fonction fibo_dyn2 qui m\u00e9mo\u00efse les solutions \u00e0 l'aide d'un dictionnaire (vide au d\u00e9part). Solution def fibo_dyn2 ( n ): if n in d : return d [ n ] elif n < 2 : d [ n ] = 1 return 1 else : d [ n ] = fibo_dyn2 ( n - 1 ) + fibo_dyn2 ( n - 2 ) return d [ n ] d = dict () print ( fibo_dyn2 ( 10 )) Comparaison de l'efficacit\u00e9 des 2 m\u00e9thodes L'activit\u00e9 est ici Une remarque importante \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent est p\u00e9dagogique car il montre bien l'int\u00e9r\u00eat de la m\u00e9mo\u00efsation. Cependant il n'y a pas besoin d' utiliser cette technique pour avoir une fonction efficace : il suffit de programmer de mani\u00e8re it\u00e9rative et non r\u00e9cursive : def fibo_iteratif ( n : int ) -> int : a , b = 1 , 1 # on initialise a = F0 et b = F1 for _ in range ( n - 1 ): a , b = b , a + b # a devient b et b devient a + b return b Il va donc falloir trouver des exemples pour lesquels on ne voit pas de version it\u00e9rative \u00e9vidente; les sous-probl\u00e8mes ne sont pas ind\u00e9pendants : sans programmation dynamique on calculerait plusieurs fois les sous solutions. Rendu de monnaie \u2693\ufe0e Nous avons d\u00e9j\u00e0 rencontr\u00e9 cette situation l'ann\u00e9e derni\u00e8re, on y appliquait un algorithme glouton : pour rendre un montant donn\u00e9, on commence par rendre les billets/pi\u00e8ces qui ont le plus de valeur et ainsi de suite. Code du rendu de monnaie glouton liste_valeurs = [ 500 , 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # la liste doit \u00eatre tri\u00e9e dans l'ordre d\u00e9croissantr def rendu_monnaie ( montant : int ) -> list : liste_rendu = [] while montant > 0 : i = 0 while liste_valeurs [ i ] > montant : i += 1 liste_rendu . append ( liste_valeurs [ i ]) montant -= liste_valeurs [ i ] return liste_rendu Avec le syst\u00e8me euro, on obtenait >>> rendu_monnaie ( 47 ) [ 20 , 20 , 5 , 2 ] Ce qui nous donne un nombre minimal de pi\u00e8ces/billets rendus. Avec le syst\u00e8me euro, l'aglorithme glouton donne toujours la solution optimale, mais ce n'est pas toujours le cas ! Par exemple, en utilisant l'ancien syst\u00e8me mon\u00e9taire Anglais >>> liste_valeurs = [ 30 , 24 , 12 , 6 , 3 , 1 ] # ancien syst\u00e8me Anglais >>> rendu_monnaie ( 48 ) [ 30 , 12 , 6 ] Or la solution optimale est [ 24 , 24 ] ... Notre algorithme glouton ne convient donc pas dans toutes les situations. Or nous voulons, pour un syst\u00e8me mon\u00e9taire donn\u00e9, trouver le plus petit nombre de pi\u00e8ces/billets n\u00e9cessaires pour rendre une somme quelconque. On va utiliser une m\u00e9thode de type \u00ab diviser pour r\u00e9gner \u00bb. Soit \\(n\\) la somme \u00e0 rendre, strictement positive; \\(\\mathscr{P}=\\{P_0;\\,...;\\,P_k\\}\\) le syst\u00e8me mon\u00e9taire; \\(R(n)\\) le nombre minimum de pi\u00e8ces pour rendre \\(n\\) selon \\(\\mathscr{P}\\) . Alors : si \\(n\\in\\mathscr{P}\\) cela veut dire qu'une pi\u00e8ce suffit et alors \\(R(n)=1\\) . sinon, appelons \\(\\mathscr{P}_n=\\{x \\in\\mathscr{P},\\, x < n\\}\\) l'ensemble des pi\u00e8ces qui valent moins que \\(n\\) . Alors il suffit de regarder ce que vaut \\(R(n-x)\\) pour tout \\(x\\in\\mathscr{P}_n\\) ; prendre le minimum \\(m\\) de toutes ces valeurs; et ainsi \\(R(n)= 1 + m\\) . \\(R_n=\\begin{cases}1 & \\mbox{si } n\\in\\mathscr{P}\\\\ 1+ min(\\{R(n-x),\\, x\\in\\mathscr{P},\\, x<n\\}) &\\mbox{sinon}\\end{cases}\\) On peut illustrer cette m\u00e9thode pour rendre 7 livres dans l'ancien syst\u00e8me mon\u00e9taire Anglais : On se rend compte que 2 pieces suffisent pour rendre la monnaie mais on voit aussi que \\(R(4)\\) est calcul\u00e9 2 fois, ainsi que \\(R(3)\\) , et caetera : les sous-probl\u00e8mes sont loins d'\u00eatre ind\u00e9pendants, la programmation dynamique va nous aider ! Programmation dynamique du rendu de monnaie optimal L'activit\u00e9 est ici. Alignement de s\u00e9quences \u2693\ufe0e On dispose de deux cha\u00eenes de caract\u00e8res : A , qui vaut INFORMATIQUE , et B , qui vaut NUMERIQUE . On aimerait mettre ces deux cha\u00eenes de caract\u00e8res en correspondance de la mani\u00e8re suivante : On place les 2 cha\u00eenes l'une en desous de l'autre; Si les derniers caract\u00e8res des deux cha\u00eenes co\u00efncident, alors on passe aux caract\u00e8res suivants; Sinon, on va ajouter un trou dans une des deux cha\u00eenes (mais laquelle ?), symbolis\u00e9 par un - et on passe aux caract\u00e8res suivant. Voici ce que cela donne : Dans cette situation on a besoin de 9 tirets, pas moins. L'objectif est d'aligner le maximum de lettres (donc de mettre le moins de - possible). Ce n'est pas un probl\u00e8me simple, surtout quand les cha\u00eenes sont longues : Ici pas moins de 26 tirets sont n\u00e9cessaires. Cette technique est utilis\u00e9e en biologie pour mettre (entre autres) en \u00e9vidence des parties communes \u00e0 deux s\u00e9quences d'ADN. Encore une fois, on d\u00e9compose un probl\u00e8me en sous-probl\u00e8mes non-ind\u00e9pendants, comme le montre l'exemple suivant, qui n\u00e9c\u00e9ssite 4 tirets : Et dont le graphe de r\u00e9solution est le suivant : Exercice Question Quel est le chemin qui correspond \u00e0 la solution anim\u00e9e ? R\u00e9ponse Bas, gauche, gauche, droite, droite, bas. Le graphe de r\u00e9solution n'est pas un arbre : les sous-probl\u00e8mes ne sont pas ind\u00e9pendants, on a tout int\u00e9r\u00eat \u00e0 utiliser la programmation dynamique. Notons aussi qu'on peut r\u00e9soudre le probl\u00e8me de 2 mani\u00e8res : on peut aligner les 2 cha\u00eenes \u00ab \u00e0 gauche \u00bb et proc\u00e9der sans le sens de la lecture; on peut aussi les aligner \u00ab \u00e0 droite \u00bb et proc\u00e9der de droite \u00e0 gauche. Enfin, il n'y a pas toujours unicit\u00e9 de la solution, comme le prouve l'exemple ci-dessous : BEC B-EC BE-C BAC BA-C B-AC Il y a au moins deux m\u00e9thodes pour programmer cet algorithme : R\u00e9cursivement, comme on l'a fait pour le rendu de monnaie; It\u00e9rativement, \u00e0 l'aide d'une matrice. Programmation dynamique it\u00e9rative de l'alignement de s\u00e9quence L'activit\u00e9 est ici. .","title":"CH25 : programmation dynamique"},{"location":"nsi2/ch25/programmation_dynamique.html#programmation-dynamique","text":"","title":"Programmation dynamique"},{"location":"nsi2/ch25/programmation_dynamique.html#un-exemple-bien-connu","text":"Nous commen\u00e7ons \u00e0 bien conna\u00eetre la suite de Fibonacci \\[F_n=\\begin{cases}1 & \\mbox{si } n=0\\mbox{ ou }n=1\\\\ F_{n-1}+F_{n-2} &\\mbox{sinon}\\end{cases}\\] Si on la programme na\u00efvement de mani\u00e8re r\u00e9cursive, voici ce qu'on obtient : def fibo ( n ): if n < 2 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Or, voici l'arbre des appels r\u00e9cursifs lors de l'ex\u00e9cution de fibo(4) : Et pour fibo(5) on obtient : Lors de cet appel, fibo(3) est appel\u00e9e 2 fois, fibo(2) 3 fois, fibo(1) 5 fois et fibo(0) 3 fois ! Il n'est donc pas \u00e9tonnant que fibo(40) prenne quelques secondes. Quant \u00e0 fibo(100) , ce n'est m\u00eame pas la peine d'y penser ! Notre strat\u00e9gie, de type \u00ab diviser pour r\u00e9gner \u00bb, d\u00e9compose le calcul de fibo(n) en 2 calculs plus simples, mais ces probl\u00e8mes ne sont pas ind\u00e9pendants , comme l'illustre le graphe suivant, obtenu \u00e0 partir du sch\u00e9ma pr\u00e9c\u00e9dent.","title":"Un exemple bien connu"},{"location":"nsi2/ch25/programmation_dynamique.html#la-memoisation","text":"D\u00e9finition : m\u00e9mo\u00efsation C'est le fait de garder en m\u00e9moire les solutions des sous-probl\u00e8mes pour pouvoir les r\u00e9utiliser sans avoir \u00e0 les d\u00e9terminer de nouveau. Cela veut dire qu'avant de renvoyer un r\u00e9sultat, la fonction le stocke (dans une liste ou un dictionnaire). Ce qui est fort agr\u00e9able, c'est que les listes et les dictionnaires sont de type mutable , ce qui nous permet d'\u00e9crire ceci : solution = [ 1 , 1 ] # on sait que les 2 premiers termes sont 1 def fibo_dyn ( n ): if n >= len ( solution ): # si solution[n] n'existe pas r = fibo_dyn ( n - 1 ) + fibo_dyn ( n - 2 ) # on calcule r\u00e9cursivement solution . append ( r ) # puis on stocke la solution return r # et on la renvoie else : return solution [ n ] # sinon on renvoie la solution d\u00e9j\u00e0 calcul\u00e9e print ( fibo_dyn ( 500 )) Et l\u00e0, on peut calculer rapidement que \\(F_{40}=165\\,580\\,141\\) , et m\u00eame que \\(\\scriptsize F_ {500}=225\\,591\\,516\\,161\\,936\\,330\\,872\\,512\\,695\\,036\\,072\\,072\\,046\\,011\\,324\\,913\\,758\\,190\\,588\\,638\\,866\\,418\\,474\\,627\\,738\\,686\\,883\\,405\\,015\\,987\\,052\\,796\\,968\\,498\\,626\\) Le fait d'utiliser la m\u00e9mo\u00efsation rend les choses bien plus rapides ! Exercice : programmation dynamique de la suite de Fibonacci En s'inspirant du script pr\u00e9c\u00e9dent, \u00e9crire la fonction fibo_dyn2 qui m\u00e9mo\u00efse les solutions \u00e0 l'aide d'un dictionnaire (vide au d\u00e9part). Solution def fibo_dyn2 ( n ): if n in d : return d [ n ] elif n < 2 : d [ n ] = 1 return 1 else : d [ n ] = fibo_dyn2 ( n - 1 ) + fibo_dyn2 ( n - 2 ) return d [ n ] d = dict () print ( fibo_dyn2 ( 10 )) Comparaison de l'efficacit\u00e9 des 2 m\u00e9thodes L'activit\u00e9 est ici","title":"La m\u00e9mo\u00efsation"},{"location":"nsi2/ch25/programmation_dynamique.html#une-remarque-importante","text":"L'exemple pr\u00e9c\u00e9dent est p\u00e9dagogique car il montre bien l'int\u00e9r\u00eat de la m\u00e9mo\u00efsation. Cependant il n'y a pas besoin d' utiliser cette technique pour avoir une fonction efficace : il suffit de programmer de mani\u00e8re it\u00e9rative et non r\u00e9cursive : def fibo_iteratif ( n : int ) -> int : a , b = 1 , 1 # on initialise a = F0 et b = F1 for _ in range ( n - 1 ): a , b = b , a + b # a devient b et b devient a + b return b Il va donc falloir trouver des exemples pour lesquels on ne voit pas de version it\u00e9rative \u00e9vidente; les sous-probl\u00e8mes ne sont pas ind\u00e9pendants : sans programmation dynamique on calculerait plusieurs fois les sous solutions.","title":"Une remarque importante"},{"location":"nsi2/ch25/programmation_dynamique.html#rendu-de-monnaie","text":"Nous avons d\u00e9j\u00e0 rencontr\u00e9 cette situation l'ann\u00e9e derni\u00e8re, on y appliquait un algorithme glouton : pour rendre un montant donn\u00e9, on commence par rendre les billets/pi\u00e8ces qui ont le plus de valeur et ainsi de suite. Code du rendu de monnaie glouton liste_valeurs = [ 500 , 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # la liste doit \u00eatre tri\u00e9e dans l'ordre d\u00e9croissantr def rendu_monnaie ( montant : int ) -> list : liste_rendu = [] while montant > 0 : i = 0 while liste_valeurs [ i ] > montant : i += 1 liste_rendu . append ( liste_valeurs [ i ]) montant -= liste_valeurs [ i ] return liste_rendu Avec le syst\u00e8me euro, on obtenait >>> rendu_monnaie ( 47 ) [ 20 , 20 , 5 , 2 ] Ce qui nous donne un nombre minimal de pi\u00e8ces/billets rendus. Avec le syst\u00e8me euro, l'aglorithme glouton donne toujours la solution optimale, mais ce n'est pas toujours le cas ! Par exemple, en utilisant l'ancien syst\u00e8me mon\u00e9taire Anglais >>> liste_valeurs = [ 30 , 24 , 12 , 6 , 3 , 1 ] # ancien syst\u00e8me Anglais >>> rendu_monnaie ( 48 ) [ 30 , 12 , 6 ] Or la solution optimale est [ 24 , 24 ] ... Notre algorithme glouton ne convient donc pas dans toutes les situations. Or nous voulons, pour un syst\u00e8me mon\u00e9taire donn\u00e9, trouver le plus petit nombre de pi\u00e8ces/billets n\u00e9cessaires pour rendre une somme quelconque. On va utiliser une m\u00e9thode de type \u00ab diviser pour r\u00e9gner \u00bb. Soit \\(n\\) la somme \u00e0 rendre, strictement positive; \\(\\mathscr{P}=\\{P_0;\\,...;\\,P_k\\}\\) le syst\u00e8me mon\u00e9taire; \\(R(n)\\) le nombre minimum de pi\u00e8ces pour rendre \\(n\\) selon \\(\\mathscr{P}\\) . Alors : si \\(n\\in\\mathscr{P}\\) cela veut dire qu'une pi\u00e8ce suffit et alors \\(R(n)=1\\) . sinon, appelons \\(\\mathscr{P}_n=\\{x \\in\\mathscr{P},\\, x < n\\}\\) l'ensemble des pi\u00e8ces qui valent moins que \\(n\\) . Alors il suffit de regarder ce que vaut \\(R(n-x)\\) pour tout \\(x\\in\\mathscr{P}_n\\) ; prendre le minimum \\(m\\) de toutes ces valeurs; et ainsi \\(R(n)= 1 + m\\) . \\(R_n=\\begin{cases}1 & \\mbox{si } n\\in\\mathscr{P}\\\\ 1+ min(\\{R(n-x),\\, x\\in\\mathscr{P},\\, x<n\\}) &\\mbox{sinon}\\end{cases}\\) On peut illustrer cette m\u00e9thode pour rendre 7 livres dans l'ancien syst\u00e8me mon\u00e9taire Anglais : On se rend compte que 2 pieces suffisent pour rendre la monnaie mais on voit aussi que \\(R(4)\\) est calcul\u00e9 2 fois, ainsi que \\(R(3)\\) , et caetera : les sous-probl\u00e8mes sont loins d'\u00eatre ind\u00e9pendants, la programmation dynamique va nous aider ! Programmation dynamique du rendu de monnaie optimal L'activit\u00e9 est ici.","title":"Rendu de monnaie"},{"location":"nsi2/ch25/programmation_dynamique.html#alignement-de-sequences","text":"On dispose de deux cha\u00eenes de caract\u00e8res : A , qui vaut INFORMATIQUE , et B , qui vaut NUMERIQUE . On aimerait mettre ces deux cha\u00eenes de caract\u00e8res en correspondance de la mani\u00e8re suivante : On place les 2 cha\u00eenes l'une en desous de l'autre; Si les derniers caract\u00e8res des deux cha\u00eenes co\u00efncident, alors on passe aux caract\u00e8res suivants; Sinon, on va ajouter un trou dans une des deux cha\u00eenes (mais laquelle ?), symbolis\u00e9 par un - et on passe aux caract\u00e8res suivant. Voici ce que cela donne : Dans cette situation on a besoin de 9 tirets, pas moins. L'objectif est d'aligner le maximum de lettres (donc de mettre le moins de - possible). Ce n'est pas un probl\u00e8me simple, surtout quand les cha\u00eenes sont longues : Ici pas moins de 26 tirets sont n\u00e9cessaires. Cette technique est utilis\u00e9e en biologie pour mettre (entre autres) en \u00e9vidence des parties communes \u00e0 deux s\u00e9quences d'ADN. Encore une fois, on d\u00e9compose un probl\u00e8me en sous-probl\u00e8mes non-ind\u00e9pendants, comme le montre l'exemple suivant, qui n\u00e9c\u00e9ssite 4 tirets : Et dont le graphe de r\u00e9solution est le suivant : Exercice Question Quel est le chemin qui correspond \u00e0 la solution anim\u00e9e ? R\u00e9ponse Bas, gauche, gauche, droite, droite, bas. Le graphe de r\u00e9solution n'est pas un arbre : les sous-probl\u00e8mes ne sont pas ind\u00e9pendants, on a tout int\u00e9r\u00eat \u00e0 utiliser la programmation dynamique. Notons aussi qu'on peut r\u00e9soudre le probl\u00e8me de 2 mani\u00e8res : on peut aligner les 2 cha\u00eenes \u00ab \u00e0 gauche \u00bb et proc\u00e9der sans le sens de la lecture; on peut aussi les aligner \u00ab \u00e0 droite \u00bb et proc\u00e9der de droite \u00e0 gauche. Enfin, il n'y a pas toujours unicit\u00e9 de la solution, comme le prouve l'exemple ci-dessous : BEC B-EC BE-C BAC BA-C B-AC Il y a au moins deux m\u00e9thodes pour programmer cet algorithme : R\u00e9cursivement, comme on l'a fait pour le rendu de monnaie; It\u00e9rativement, \u00e0 l'aide d'une matrice. Programmation dynamique it\u00e9rative de l'alignement de s\u00e9quence L'activit\u00e9 est ici. .","title":"Alignement de s\u00e9quences"},{"location":"nsi2/ch26/recherche_textuelle.html","text":"Recherche textuelle \u2693\ufe0e Il s'agit pour nous de trouver un motif ( pattern en anglais) dans un texte. L'algorithme na\u00eff \u2693\ufe0e La mani\u00e8re la plus simple de proc\u00e9der est de commencer par comparer les premiers caract\u00e8res du texte et du motif tant qu'ils sont diff\u00e9rents, on compare le premier caract\u00e8re du motif avec le caract\u00e8re du texte suivant; si ils sont \u00e9gaux alors on retient la position du caract\u00e8re dans le texte et tant qu'ils sont \u00e9gaux ou que l'on n'est pas arriv\u00e9 au bout du motif ou de la chaine, on compare les caract\u00e8res suivants. Si on a atteint la fin du motif, c'est qu'il figure dans le texte \u00e0 la position retenue. Cet algorithme n'est pas tr\u00e8s performant, voici un cas pathologique : prenons pour motif \\(M\\) , un mot de \\(m\\) caract\u00e8res; consid\u00e9rons le motif \\(M'\\) compos\u00e9 des \\(m-1\\) premiers caract\u00e8res de \\(M\\) auquel on ajoute en guise de dernier caract\u00e8re un caract\u00e8re diff\u00e9rent du dernier de \\(M\\) ; fabriquons un texte compos\u00e9 d'une r\u00e9p\u00e9tition de \\(M'\\) et appelons \\(n\\) sa longueur. Dans ce cas l'algorithme va n\u00e9cessiter \\(n\\times m\\) comparaisons pour d\u00e9terminer que \\(M\\) ne figure pas dans le texte. On pourrait alors penser \u00e0 aligner le motif avec le texte; commencer par comparer le dernier caract\u00e8re du motif avec le caract\u00e8re correspondant du texte; tant qu'ils sont \u00e9gaux et qu'on a pas \u00e9puis\u00e9 les lettres du motif, on \" se d\u00e9cale d'un cran vers la gauche \"; tant qu'ils sont diff\u00e9rents et qu'on est pas arriv\u00e9 au bout du texte, on d\u00e9cale le motif d'un cran vers la droite. Malheureusement, cet algorithme souffre des m\u00eames faiblesses que son pr\u00e9d\u00e9cesseur comme le montre l'exemple suivant : PATATE = RATA les deux lettres sont \u00e9gales, on continue \u00e0 comparer PATATE = RATA PATATE = RATA PATATE \u2260 RATA les deux lettres diff\u00e8rent, on d\u00e9cale vers la droite PATATE \u2260 RATA idem PATATE \u2260 RATA termin\u00e9 : RATA n'est pas dans PATATE Mais tout n'est pas perdu car on peut am\u00e9liorer l'algorithme : FABRIQUER \u2260 POT les lettres diff\u00e8rent et il n'y a pas de B dans POT donc on peut continuer en d\u00e9calant POT de 3 lettres ! FABRIQUER \u2260 POT idem FABRIQUER \u2260 POT termin\u00e9 ! Comme on peut le constater, seules 3 comparaisons ont \u00e9t\u00e9 n\u00e9cessaires pour conclure. Avec l'algorithme na\u00eff il en aurait fallu 6. Ceci dit, que faire quand on compare le dernier caract\u00e8re du motif avec un caract\u00e8re du texte et que ceux-ci sont diff\u00e9rent mais que le caract\u00e8re du texte appara\u00eet quand m\u00eame dans le motif ? Regardons l'exemple suivant : ANTICONSTITUTIONNELLEMENT On commence ainsi ^ CONIQUE ANTICONSTITUTIONNELLEMENT Les 2 lettres diff\u00e8rent mais N apparait dans CONIQUE \u2260 donc on aligne les N CONIQUE ANTICONSTITUTIONNELLEMENT ^ CONIQUE ANTICONSTITUTIONNELLEMENT Mais \u00e0 ce moment l\u00e0 les 2 lettres diff\u00e8rent et T n'apppara\u00eet \u2260 CONIQUE pas dans CONIQUE donc on peut d\u00e9caler de 7 lettres ANTICONSTITUTIONNELLEMENT ^ CONIQUE ANTICONSTITUTIONNELLEMENT Les 2 co\u00efncident = CONIQUE ANTICONSTITUTIONNELLEMENT Mais \u2260 CONIQUE ANTICONSTITUTIONNELLEMENT ^ CONIQUE ^ ANTICONSTITUTIONNELLEMENT \u2260 CONIQUE \u2260 La m\u00e9thode que l'on vient d'appliquer est l'algorithme de Boyer-Moore-Horspool . L'algorithme de Boyer-Moore-Horspool \u2693\ufe0e Ce qu'il faut retenir c'est que Il y a d'abord pr\u00e9-traitement du motif \u00e0 rechercher pour \u00e9tablir une table de sauts . On compare le motif avec le texte en commen\u00e7ant par le dernier caract\u00e8re du motif. Tant que les caract\u00e8res co\u00efncident on compare les caract\u00e8res pr\u00e9c\u00e9dents (et \u00e9ventuellement on trouve le motif). D\u00e8s que les caract\u00e8res ne co\u00efncident pas, on utilise la table de saut avec le caract\u00e8re du texte align\u00e9 avec le dernier caract\u00e8re du motif. Exemple \u2693\ufe0e On consid\u00e8re la cha\u00eene de caract\u00e8res JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE. On voudrait savoir si le motif TROUVER figure dans cette cha\u00eene. Pr\u00e9-traitement du motif \u2693\ufe0e Commen\u00e7ons par \u00e9tablir la table de saut du motif. C'est simple : on parcourt le motif caract\u00e8re par caract\u00e8re jusqu'\u00e0 l'avant dernier; \u00e0 chaque fois on note le nombre de caract\u00e8res qui le s\u00e9pare du dernier; si un caract\u00e8re appara\u00eet plusieurs fois, c'est la derni\u00e8re qui prime; le nombre que l'on obtient est l'amplitude du d\u00e9calage \u00e0 faire subir au motif lorsque son dernier caract\u00e8re est align\u00e9 avec le caract\u00e8re courant; toutes les autres lettres n'apparaissent pas dans le motif (ou alors \u00e0 la fin du motif et seulement \u00e0 la fin) et donc on peut leur associer une saut d'amplitude la longueur du motif. caract\u00e8re amplitude du saut T 6 R 5 O 4 U 3 V 2 E 1 autre 7 Parcours du texte \u2693\ufe0e JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE On commence ainsi ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un I on d\u00e9cale de 7 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un E on d\u00e9cale de 1 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un N on d\u00e9cale de 7 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un O on d\u00e9cale de 4 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres \u00e9gales, on continue \u00e0 comparer = en allant de droite \u00e0 gauche TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un R on d\u00e9cale de 5 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes \u2260 TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Pour un A on d\u00e9cale de 7 ^ TROUVER JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE Lettres diff\u00e9rentes, on devrait d\u00e9caler mais on d\u00e9passerait \u2260 donc c'est termin\u00e9 TROUVER L'algorithme a n\u00e9c\u00e9ssit\u00e9 8 comparaisons, on se doute qu'il en aurait fallu bien plus avec l'algorithme na\u00eff. Programmation de l'algorithme de Boyer-Moore-Horspool L'activit\u00e9 est ici .","title":"CH26 : recherche textuelle"},{"location":"nsi2/ch26/recherche_textuelle.html#recherche-textuelle","text":"Il s'agit pour nous de trouver un motif ( pattern en anglais) dans un texte.","title":"Recherche textuelle"},{"location":"nsi2/ch26/recherche_textuelle.html#lalgorithme-naif","text":"La mani\u00e8re la plus simple de proc\u00e9der est de commencer par comparer les premiers caract\u00e8res du texte et du motif tant qu'ils sont diff\u00e9rents, on compare le premier caract\u00e8re du motif avec le caract\u00e8re du texte suivant; si ils sont \u00e9gaux alors on retient la position du caract\u00e8re dans le texte et tant qu'ils sont \u00e9gaux ou que l'on n'est pas arriv\u00e9 au bout du motif ou de la chaine, on compare les caract\u00e8res suivants. Si on a atteint la fin du motif, c'est qu'il figure dans le texte \u00e0 la position retenue. Cet algorithme n'est pas tr\u00e8s performant, voici un cas pathologique : prenons pour motif \\(M\\) , un mot de \\(m\\) caract\u00e8res; consid\u00e9rons le motif \\(M'\\) compos\u00e9 des \\(m-1\\) premiers caract\u00e8res de \\(M\\) auquel on ajoute en guise de dernier caract\u00e8re un caract\u00e8re diff\u00e9rent du dernier de \\(M\\) ; fabriquons un texte compos\u00e9 d'une r\u00e9p\u00e9tition de \\(M'\\) et appelons \\(n\\) sa longueur. Dans ce cas l'algorithme va n\u00e9cessiter \\(n\\times m\\) comparaisons pour d\u00e9terminer que \\(M\\) ne figure pas dans le texte. On pourrait alors penser \u00e0 aligner le motif avec le texte; commencer par comparer le dernier caract\u00e8re du motif avec le caract\u00e8re correspondant du texte; tant qu'ils sont \u00e9gaux et qu'on a pas \u00e9puis\u00e9 les lettres du motif, on \" se d\u00e9cale d'un cran vers la gauche \"; tant qu'ils sont diff\u00e9rents et qu'on est pas arriv\u00e9 au bout du texte, on d\u00e9cale le motif d'un cran vers la droite. Malheureusement, cet algorithme souffre des m\u00eames faiblesses que son pr\u00e9d\u00e9cesseur comme le montre l'exemple suivant : PATATE = RATA les deux lettres sont \u00e9gales, on continue \u00e0 comparer PATATE = RATA PATATE = RATA PATATE \u2260 RATA les deux lettres diff\u00e8rent, on d\u00e9cale vers la droite PATATE \u2260 RATA idem PATATE \u2260 RATA termin\u00e9 : RATA n'est pas dans PATATE Mais tout n'est pas perdu car on peut am\u00e9liorer l'algorithme : FABRIQUER \u2260 POT les lettres diff\u00e8rent et il n'y a pas de B dans POT donc on peut continuer en d\u00e9calant POT de 3 lettres ! FABRIQUER \u2260 POT idem FABRIQUER \u2260 POT termin\u00e9 ! Comme on peut le constater, seules 3 comparaisons ont \u00e9t\u00e9 n\u00e9cessaires pour conclure. Avec l'algorithme na\u00eff il en aurait fallu 6. Ceci dit, que faire quand on compare le dernier caract\u00e8re du motif avec un caract\u00e8re du texte et que ceux-ci sont diff\u00e9rent mais que le caract\u00e8re du texte appara\u00eet quand m\u00eame dans le motif ? Regardons l'exemple suivant : ANTICONSTITUTIONNELLEMENT On commence ainsi ^ CONIQUE ANTICONSTITUTIONNELLEMENT Les 2 lettres diff\u00e8rent mais N apparait dans CONIQUE \u2260 donc on aligne les N CONIQUE ANTICONSTITUTIONNELLEMENT ^ CONIQUE ANTICONSTITUTIONNELLEMENT Mais \u00e0 ce moment l\u00e0 les 2 lettres diff\u00e8rent et T n'apppara\u00eet \u2260 CONIQUE pas dans CONIQUE donc on peut d\u00e9caler de 7 lettres ANTICONSTITUTIONNELLEMENT ^ CONIQUE ANTICONSTITUTIONNELLEMENT Les 2 co\u00efncident = CONIQUE ANTICONSTITUTIONNELLEMENT Mais \u2260 CONIQUE ANTICONSTITUTIONNELLEMENT ^ CONIQUE ^ ANTICONSTITUTIONNELLEMENT \u2260 CONIQUE \u2260 La m\u00e9thode que l'on vient d'appliquer est l'algorithme de Boyer-Moore-Horspool .","title":"L'algorithme na\u00eff"},{"location":"nsi2/ch26/recherche_textuelle.html#lalgorithme-de-boyer-moore-horspool","text":"Ce qu'il faut retenir c'est que Il y a d'abord pr\u00e9-traitement du motif \u00e0 rechercher pour \u00e9tablir une table de sauts . On compare le motif avec le texte en commen\u00e7ant par le dernier caract\u00e8re du motif. Tant que les caract\u00e8res co\u00efncident on compare les caract\u00e8res pr\u00e9c\u00e9dents (et \u00e9ventuellement on trouve le motif). D\u00e8s que les caract\u00e8res ne co\u00efncident pas, on utilise la table de saut avec le caract\u00e8re du texte align\u00e9 avec le dernier caract\u00e8re du motif.","title":"L'algorithme de Boyer-Moore-Horspool"},{"location":"nsi2/ch26/recherche_textuelle.html#exemple","text":"On consid\u00e8re la cha\u00eene de caract\u00e8res JENESAISVRAIMENTPASQUOIECRIREDANSCETEXTE. On voudrait savoir si le motif TROUVER figure dans cette cha\u00eene.","title":"Exemple"},{"location":"nsi2/ch27/protocoles_de_routage.html","text":"Protocoles de routages \u2693\ufe0e Situation \u2693\ufe0e Lors d'une communication via un r\u00e9seau, une machine appel\u00e9e client doit envoyer une information \u00e0 une autre machine appel\u00e9e serveur . Les termes client et serveur sont tr\u00e8s larges et peuvent en fait d\u00e9signer une machine aussi bien qu'une application s'ex\u00e9cutant sur cette machine; alterner au cours du temps (le client devient serveur et vice-versa). On a vu en classe de premi\u00e8re que l'information va \u00eatre d\u00e9coup\u00e9e en de multiples paquets de petite taille, et ces paquets doivent arriver \u00e0 destination. Le troisi\u00e8me \u00e9l\u00e9ment de la communication sont les routeurs . Ils peuvent \u00eatre de deux types routeurs d'acc\u00e8s lorsqu'ils sont en bordure de r\u00e9seau , c'est \u00e0 dire qu'ils sont directement interfac\u00e9s avec un r\u00e9seau local . internes sinon. Voici un sch\u00e9ma qui montre la topologie d'un r\u00e9seau, c'est \u00e0 dire son architecture : Explications sur les paires (sous-r\u00e9seau/masque) Une paire (sous-r\u00e9seau/masque) est compos\u00e9e de l'adresse IP du r\u00e9seau, not\u00e9e sur 4 octets, soit 32 bits; du nombres de bits qui correspondent \u00e0 la partie fixe des IP du r\u00e9seau. Par exemple, le r\u00e9seau local du client est 192.168.1.0/24 ce qui veut dire que : l'adresse IP du r\u00e9seau est 192.168.1.0; les 24 bits (dans le sens de la lecture) sont fixes. Puisque qu'une adresse IP est cod\u00e9e sur 32 octets, cela veut dire que seuls les 8 derniers bits (c'est-\u00e0-dire le dernier octet) peuvent varier. L'ensemble des IP de ce r\u00e9seau est donc - 192.168.1.0 : l'IP du r\u00e9seau m\u00eame; - 192.168.1.x : l'IP des machines du r\u00e9seaux, avec \\(1\\leqslant x\\leqslant 254\\) (soit 254 machines au total; - 192.168.1.255 : l'IP du r\u00e9seau d\u00e9di\u00e9e \u00e0 la diffusion en masse ( broadcast ). Le r\u00e9seau comprenant R1 et R3 a pour adresse 10.0.1.0/30 : il ne reste donc que 2 bits libres pour adresser les machines, soit 4 possibilit\u00e9s. Si on enl\u00e8ve l'adresse r\u00e9seau 10.0.1.0 et l'adresse broadcast 10.0.1.3 il reste 2 IP, une pour chaque routeur. Ajoutons que R1 poss\u00e8de aussi une IP dans le r\u00e9seau local du client et r\u00e9alise ainsi une passerelle . Ainsi par exemple Dans ce r\u00e9seau R1 peut avoir l'IP 10.0.1.1 et R3 10.0.1.2 (ou l'inverse). Lorsqu'un paquet doit transiter du client au serveur, il doit obligatoirement passer la passerelle R1 et l\u00e0 encore il n'y a pas le choix, il passera par R3. Mais ensuite ? Comment la route \u00e0 emprunter est-elle d\u00e9termin\u00e9e ? Est-ce la m\u00eame tout le temps ? En fait, chaque routeur poss\u00e8de une table de routage qui associe les IP de destination \u00e0 des routeurs particuliers. Ces tables ne sont pas fixes et a priori tous les routeurs ont le m\u00eame statut (il n'y a pas de routeur privil\u00e9gi\u00e9). Les m\u00e9thodes qui permettent de g\u00e9rer ces tables de routage sont appel\u00e9s des protocoles de routage . Le protocole RIP \u2693\ufe0e Principe \u00c0 intervalles de temps r\u00e9gulieur, chaque routeur envoie \u00e0 ses voisins les adresses de ses propres voisins; les adresses qu'il a re\u00e7ues par d'autres routeurs Pour chaque adresse, il indique \u00e9galement combien de sauts sont n\u00e9cessaires pour l'atteindre, c'est \u00e0 dire par combien de routeurs (y compris lui-m\u00eame) il faut passer. Lorsqu'un routeur re\u00e7oit les informations d'un routeur voisin, 4 cas peuvent survenir : Une route vers un nouveau sous-r\u00e9seau lui est pr\u00e9sent\u00e9e : il l'ajoute \u00e0 sa table de routage. Une route vers un sous-r\u00e9seau d\u00e9j\u00e0 connue lui est pr\u00e9sent\u00e9e, mais plus courte que la pr\u00e9c\u00e9dente. Dans ce cas l'ancienne est remplac\u00e9e par celle-ci. Une nouvelle route plus longue lui est transmise : il l'ignore. Une route existante, passant par le m\u00eame voisin, mais plus longue que celle de la table de routage lui est pr\u00e9sent\u00e9e. Cela veut dire qu'un probl\u00e8me est survenu sur l'ancienne route. Celle-ci est donc effac\u00e9e et remplac\u00e9e par la plus longue. Pour \u00e9viter les boucles, les distances doivent \u00eatre au maximum de 15 (sinon elles sont ignor\u00e9es). RIP fonctionne donc sur des r\u00e9seaux de taille modeste. \u00c9tape 1 : initialisation \u2693\ufe0e Reprenons le r\u00e9seau pr\u00e9c\u00e9dent et int\u00e9ressons-nous uniquement aux routeurs R1 et R3. Au d\u00e9but de la mise en service du r\u00e9seau voici la table de routage de R1 : destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 Elle indique que le sous-r\u00e9seau local 192.168.1.0/24 est imm\u00e9diatement accessible via l'interface WiFi wlan0 depuis ce propre routeur R1. Elle est donc \u00e0 distance 1 de R1. De m\u00eame l'autre sous-r\u00e9seau est accessible via un port Ethernet du routeur nomm\u00e9 eth0 et est \u00e9galement \u00e0 distance 1 de R1. Voici celle de R3 : destination passerelle interface distance 10.1.1.0/30 eth1 1 10.1.2.0/30 eth2 1 10.1.3.0/30 eth3 1 10.1.4.0/30 eth0 1 C'est la m\u00eame chose : R3 est initialis\u00e9 avec ses voisins directs. Notez que les noms des interfaces sont relatifs \u00e0 R3, c'est pourquoi, par exemple, R1 et R3 sont reli\u00e9s par Ethernet sur le port eth0 de R1 et eth1 de R2. Ces ports peuvent avoir le m\u00eame nom ou pas, peu importe car ces noms n'existent que relativement au routeur concern\u00e9. \u00c9tape 2 : premi\u00e8re it\u00e9ration de RIP \u2693\ufe0e Chaque routeur envoie ses informations \u00e0 ses voisins. La table de R1 devient destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 10.0.2.0/30 10.1.1.2 eth0 2 10.0.3.0/30 10.1.1.2 eth0 2 10.0.4.0/30 10.1.1.2 eth0 2 Ainsi R1 sait qu'il peut atteindre les machines du sous-r\u00e9seau 10.1.2.0/30 via la passerelle 10.1.1.2 (IP de R2) sur le sous-r\u00e9seau 10.1.1.0/30 sur lequel R1 et R2 figurent. L'interface est eth0 et la distance est 2. Voici la table de R3 : destination passerelle interface distance 10.1.1.0/30 eth1 1 192.168.1.0/24 10.1.1.1 eth1 2 10.1.2.0/30 eth2 1 10.1.3.0/30 eth3 1 10.1.4.0/30 eth0 1 10.1.7.0/30 10.1.4.2 eth0 2 \u00c9tape 3 : convergence apr\u00e8s quelques it\u00e9rations \u2693\ufe0e Dans notre cas, apr\u00e8s 2 autres it\u00e9rations, les informations se stabilisent, on dit qu'il y a convergence et chaque routeur conna\u00eet le chemin \u00e0 emprunter pour acc\u00e9der \u00e0 n'importe quel sous-r\u00e9seau. En particulier la table de R1 est la suivante : destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 10.0.2.0/30 10.1.1.2 eth0 2 10.0.3.0/30 10.1.1.2 eth0 2 10.0.7.0/30 10.1.1.2 eth0 3 192.162.6.0/30 10.1.1.2 eth0 4 Le protocole OSPF \u2693\ufe0e \u00e0 venir","title":"CH27 : protocoles de routage"},{"location":"nsi2/ch27/protocoles_de_routage.html#protocoles-de-routages","text":"","title":"Protocoles de routages"},{"location":"nsi2/ch27/protocoles_de_routage.html#situation","text":"Lors d'une communication via un r\u00e9seau, une machine appel\u00e9e client doit envoyer une information \u00e0 une autre machine appel\u00e9e serveur . Les termes client et serveur sont tr\u00e8s larges et peuvent en fait d\u00e9signer une machine aussi bien qu'une application s'ex\u00e9cutant sur cette machine; alterner au cours du temps (le client devient serveur et vice-versa). On a vu en classe de premi\u00e8re que l'information va \u00eatre d\u00e9coup\u00e9e en de multiples paquets de petite taille, et ces paquets doivent arriver \u00e0 destination. Le troisi\u00e8me \u00e9l\u00e9ment de la communication sont les routeurs . Ils peuvent \u00eatre de deux types routeurs d'acc\u00e8s lorsqu'ils sont en bordure de r\u00e9seau , c'est \u00e0 dire qu'ils sont directement interfac\u00e9s avec un r\u00e9seau local . internes sinon. Voici un sch\u00e9ma qui montre la topologie d'un r\u00e9seau, c'est \u00e0 dire son architecture : Explications sur les paires (sous-r\u00e9seau/masque) Une paire (sous-r\u00e9seau/masque) est compos\u00e9e de l'adresse IP du r\u00e9seau, not\u00e9e sur 4 octets, soit 32 bits; du nombres de bits qui correspondent \u00e0 la partie fixe des IP du r\u00e9seau. Par exemple, le r\u00e9seau local du client est 192.168.1.0/24 ce qui veut dire que : l'adresse IP du r\u00e9seau est 192.168.1.0; les 24 bits (dans le sens de la lecture) sont fixes. Puisque qu'une adresse IP est cod\u00e9e sur 32 octets, cela veut dire que seuls les 8 derniers bits (c'est-\u00e0-dire le dernier octet) peuvent varier. L'ensemble des IP de ce r\u00e9seau est donc - 192.168.1.0 : l'IP du r\u00e9seau m\u00eame; - 192.168.1.x : l'IP des machines du r\u00e9seaux, avec \\(1\\leqslant x\\leqslant 254\\) (soit 254 machines au total; - 192.168.1.255 : l'IP du r\u00e9seau d\u00e9di\u00e9e \u00e0 la diffusion en masse ( broadcast ). Le r\u00e9seau comprenant R1 et R3 a pour adresse 10.0.1.0/30 : il ne reste donc que 2 bits libres pour adresser les machines, soit 4 possibilit\u00e9s. Si on enl\u00e8ve l'adresse r\u00e9seau 10.0.1.0 et l'adresse broadcast 10.0.1.3 il reste 2 IP, une pour chaque routeur. Ajoutons que R1 poss\u00e8de aussi une IP dans le r\u00e9seau local du client et r\u00e9alise ainsi une passerelle . Ainsi par exemple Dans ce r\u00e9seau R1 peut avoir l'IP 10.0.1.1 et R3 10.0.1.2 (ou l'inverse). Lorsqu'un paquet doit transiter du client au serveur, il doit obligatoirement passer la passerelle R1 et l\u00e0 encore il n'y a pas le choix, il passera par R3. Mais ensuite ? Comment la route \u00e0 emprunter est-elle d\u00e9termin\u00e9e ? Est-ce la m\u00eame tout le temps ? En fait, chaque routeur poss\u00e8de une table de routage qui associe les IP de destination \u00e0 des routeurs particuliers. Ces tables ne sont pas fixes et a priori tous les routeurs ont le m\u00eame statut (il n'y a pas de routeur privil\u00e9gi\u00e9). Les m\u00e9thodes qui permettent de g\u00e9rer ces tables de routage sont appel\u00e9s des protocoles de routage .","title":"Situation"},{"location":"nsi2/ch27/protocoles_de_routage.html#le-protocole-rip","text":"Principe \u00c0 intervalles de temps r\u00e9gulieur, chaque routeur envoie \u00e0 ses voisins les adresses de ses propres voisins; les adresses qu'il a re\u00e7ues par d'autres routeurs Pour chaque adresse, il indique \u00e9galement combien de sauts sont n\u00e9cessaires pour l'atteindre, c'est \u00e0 dire par combien de routeurs (y compris lui-m\u00eame) il faut passer. Lorsqu'un routeur re\u00e7oit les informations d'un routeur voisin, 4 cas peuvent survenir : Une route vers un nouveau sous-r\u00e9seau lui est pr\u00e9sent\u00e9e : il l'ajoute \u00e0 sa table de routage. Une route vers un sous-r\u00e9seau d\u00e9j\u00e0 connue lui est pr\u00e9sent\u00e9e, mais plus courte que la pr\u00e9c\u00e9dente. Dans ce cas l'ancienne est remplac\u00e9e par celle-ci. Une nouvelle route plus longue lui est transmise : il l'ignore. Une route existante, passant par le m\u00eame voisin, mais plus longue que celle de la table de routage lui est pr\u00e9sent\u00e9e. Cela veut dire qu'un probl\u00e8me est survenu sur l'ancienne route. Celle-ci est donc effac\u00e9e et remplac\u00e9e par la plus longue. Pour \u00e9viter les boucles, les distances doivent \u00eatre au maximum de 15 (sinon elles sont ignor\u00e9es). RIP fonctionne donc sur des r\u00e9seaux de taille modeste.","title":"Le protocole RIP"},{"location":"nsi2/ch27/protocoles_de_routage.html#etape-1-initialisation","text":"Reprenons le r\u00e9seau pr\u00e9c\u00e9dent et int\u00e9ressons-nous uniquement aux routeurs R1 et R3. Au d\u00e9but de la mise en service du r\u00e9seau voici la table de routage de R1 : destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 Elle indique que le sous-r\u00e9seau local 192.168.1.0/24 est imm\u00e9diatement accessible via l'interface WiFi wlan0 depuis ce propre routeur R1. Elle est donc \u00e0 distance 1 de R1. De m\u00eame l'autre sous-r\u00e9seau est accessible via un port Ethernet du routeur nomm\u00e9 eth0 et est \u00e9galement \u00e0 distance 1 de R1. Voici celle de R3 : destination passerelle interface distance 10.1.1.0/30 eth1 1 10.1.2.0/30 eth2 1 10.1.3.0/30 eth3 1 10.1.4.0/30 eth0 1 C'est la m\u00eame chose : R3 est initialis\u00e9 avec ses voisins directs. Notez que les noms des interfaces sont relatifs \u00e0 R3, c'est pourquoi, par exemple, R1 et R3 sont reli\u00e9s par Ethernet sur le port eth0 de R1 et eth1 de R2. Ces ports peuvent avoir le m\u00eame nom ou pas, peu importe car ces noms n'existent que relativement au routeur concern\u00e9.","title":"\u00c9tape 1 : initialisation"},{"location":"nsi2/ch27/protocoles_de_routage.html#etape-2-premiere-iteration-de-rip","text":"Chaque routeur envoie ses informations \u00e0 ses voisins. La table de R1 devient destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 10.0.2.0/30 10.1.1.2 eth0 2 10.0.3.0/30 10.1.1.2 eth0 2 10.0.4.0/30 10.1.1.2 eth0 2 Ainsi R1 sait qu'il peut atteindre les machines du sous-r\u00e9seau 10.1.2.0/30 via la passerelle 10.1.1.2 (IP de R2) sur le sous-r\u00e9seau 10.1.1.0/30 sur lequel R1 et R2 figurent. L'interface est eth0 et la distance est 2. Voici la table de R3 : destination passerelle interface distance 10.1.1.0/30 eth1 1 192.168.1.0/24 10.1.1.1 eth1 2 10.1.2.0/30 eth2 1 10.1.3.0/30 eth3 1 10.1.4.0/30 eth0 1 10.1.7.0/30 10.1.4.2 eth0 2","title":"\u00c9tape 2 : premi\u00e8re it\u00e9ration de RIP"},{"location":"nsi2/ch27/protocoles_de_routage.html#etape-3-convergence-apres-quelques-iterations","text":"Dans notre cas, apr\u00e8s 2 autres it\u00e9rations, les informations se stabilisent, on dit qu'il y a convergence et chaque routeur conna\u00eet le chemin \u00e0 emprunter pour acc\u00e9der \u00e0 n'importe quel sous-r\u00e9seau. En particulier la table de R1 est la suivante : destination passerelle interface distance 10.0.1.0/30 eth0 1 192.168.1.0/24 wlan0 1 10.0.2.0/30 10.1.1.2 eth0 2 10.0.3.0/30 10.1.1.2 eth0 2 10.0.7.0/30 10.1.1.2 eth0 3 192.162.6.0/30 10.1.1.2 eth0 4","title":"\u00c9tape 3 : convergence apr\u00e8s quelques it\u00e9rations"},{"location":"nsi2/ch27/protocoles_de_routage.html#le-protocole-ospf","text":"\u00e0 venir","title":"Le protocole OSPF"},{"location":"nsi2/ch28/calculabilite.html","text":"Calculabilit\u00e9 et d\u00e9cidabilit\u00e9 \u2693\ufe0e Un peu d'Histoire et des d\u00e9finitions \u2693\ufe0e Algorithme \u2693\ufe0e Depuis l'Antiquit\u00e9 l'humanit\u00e9 utilise des m\u00e9thodes de calcul pour r\u00e9soudre des probl\u00e8mes, mais jusqu'au d\u00e9but du vingti\u00e8me si\u00e8cle on n'avait aucune d\u00e9finition pr\u00e9cise de ce qu'est une m\u00e9thode de calcul. Pourtant lors du Congr\u00e8s International des Math\u00e9maticiens de Paris de 1900, David Hilbert a formul\u00e9 24 probl\u00e8mes, dont le dixi\u00e8me dont l'\u00e9nonc\u00e9 peut \u00eatre vulgaris\u00e9 en : \u00ab Existe-t-il une m\u00e9thode g\u00e9n\u00e9rale pour d\u00e9terminer quelles \u00e9quations diophantiennes on des solutions et quelles \u00e9quations diophantiennes n'en ont pas ? \u00bb Equations diophantiennes Une \u00e9quation diophantienne est une \u00e9quation \u00e0 une ou plusieurs inconnues; polynomiale : ne figurent que des puissances enti\u00e8res des inconnues; \u00e0 coefficients entiers; dont on cherche des solutions enti\u00e8res. \\(x^2-3x+2 = 0\\) est une \u00e9quation diophantienne de solution 1 et 2. \\(x^2+y^2=z^2\\) en est une autre, ses solutions sont les triplets pythagoriciens. \\(3x^5+2xyz^3+y^2-z+2=0\\) en est une derni\u00e8re... Ce sont les math\u00e9maticiens Church, Kleene, Turing et G\u00f6del qui, entre 1931 et 1936 ont identifi\u00e9 la notion d'algorithme. Chacun d'entre eux s'int\u00e9ressa \u00e0 sa mani\u00e8re et plus ou moins ind\u00e9pendamment des autres \u00e0 une cat\u00e9gorie de fonctions. Ils reconnurent ensuite que ces diff\u00e9rentes classes co\u00efncidaient et appel\u00e8rent cette classe la classe des fonctions calculables . C'est ce qu'on appelle la th\u00e8se de Church : tous les mod\u00e8les de calculs qui ont \u00e9t\u00e9 utilis\u00e9s pour expliquer ce qu'est une fonction calculable sont \u00e9quivalents. Fonction calculable Une fonction est dite calculable s'il existe une fa\u00e7on finie de la d\u00e9crire qui permette effectivement d'en calculer toutes les valeurs. Cette d\u00e9finition fixe \u00e9galement la notion d'algorithme. Ce sont les travaux de Turing qui ont abouti la d\u00e9finition d'algorithme la plus pratique \u00e0 utiliser : en 1936 la notion d'algorithme \u00e9tait acquise. Algorithme Un algorithme est suite finie d'instructions qu'une machine de Turing peut effectuer. Depuis, on s'est employ\u00e9 \u00e0 cr\u00e9er des entit\u00e9s distinctes des machines de Turing, mais qui sont dite Turing-compl\u00e8tes , c'est-\u00e0-dire qui peuvent \u00ab faire tout ce que peut faire une machine de Turing \u00bb Les langages de programmation que nous connaissons (Python, Java, C++ *et c\u00e6tera) sont Turing-complets (ouf !), mais HTML seul (sans CSS) n'est pas Turing-complet. Fonction calculable \u2693\ufe0e Dans le cadre de notre cours on peut donc reformuler : Fonction calculable (deuxi\u00e8me d\u00e9finition) Une fonction est calculable si on peut la programmer (en Python par exemple). Probl\u00e8me d\u00e9cidable \u2693\ufe0e D\u00e8s lors, on peut s'int\u00e9resser \u00e0 la notion de probl\u00e8me d\u00e9cidable . Un probl\u00e8me de d\u00e9cision peut s'envisager ainsi cas g\u00e9n\u00e9ral exemple 1 exemple 2 Nom du probl\u00e8me Primalit\u00e9 d'un entier Probl\u00e8me de l'arr\u00eat Donn\u00e9e : sp\u00e9cification d'une instance du probl\u00e8me un entier naturel un programme (\u00e9crit en Python par exemple) R\u00e9ponse : propri\u00e9t\u00e9 portant sur une instance qui sp\u00e9cifie les instances positives du probl\u00e8me d\u00e9cider si ce nombre est premier d\u00e9cider si ce programme s'arr\u00eate Sans rentrer dans les d\u00e9tails, on peut associer aux probl\u00e8mes de d\u00e9cision des fonctions de d\u00e9cision. Un probl\u00e8me est alors appel\u00e9 d\u00e9cidable si la fonction associ\u00e9e est calculable. Cela nous permet de formuler une d\u00e9finition : Probl\u00e8me d\u00e9cidable Un probl\u00e8me est d\u00e9cidable si on peut \u00e9crire une fonction (en Python ou autre) qui en entr\u00e9e prend les donn\u00e9es du probl\u00e8me renvoie True ou False suivant que les les donn\u00e9es satisfont le probl\u00e8me ou non. Par exemple, le probl\u00e8me \u00ab \\(n\\in\\mathbb{N}\\) est-il premier ? \u00bb est-il d\u00e9cidable : def est_premier ( n : int ) -> bool : for i in range ( 2 , n ): if n % i == 0 : return False return True L'algorithme impl\u00e9ment\u00e9 en Python est fort peu efficace mais l\u00e0 n'est pas le probl\u00e8me : il existe. Donc le probl\u00e8me de la primalit\u00e9 d'un entier positif est d\u00e9cidable. Dire qu'un probl\u00e8me est ind\u00e9cidable signifie donc qu'il n'existe pas d'algorithme permettant de r\u00e9soudre ce probl\u00e8me dans tous les cas (quelles que soient les donn\u00e9es du probl\u00e8me). Nombre calculable \u2693\ufe0e Tant que nous y sommes, d\u00e9finissons ce qu'est un nombre calculable : Nombre calculable Un nombre r\u00e9el est calculable si et seulement si il existe un algorithme permettant de calculer autant de d\u00e9cimales que l'on veut de l'\u00e9criture en base 10 de ce r\u00e9el. \u00c9videmment si le nombre n'est pas une fraction, son \u00e9criture d\u00e9cimale n'est pas p\u00e9riodique, il est donc hors de question de chercher \u00e0 les conna\u00eetre toutes (sauf cas particulier o\u00f9 l'on a nous m\u00eame fabriqu\u00e9 l'\u00e9criture d\u00e9cimale du nombre). Par exemple, on peut montrer que le nombre \\(e\\) (celui qui permet de construire la fonction exponentielle) vaut \\[\\sum_{k=0}^{+\\infty}\\frac{1}{k!}=\\frac{1}{0!}+\\frac{1}{1!}+\\frac{1}{2!}+\\frac{1}{3!}+\\ldots\\] Avec \\(0!=1\\) , rappelons-le. Il y a une infinit\u00e9 de termes dans la somme (c'est une limite), mais en prenant un nombre suffisant des premiers termes de cette somme, on peut en d\u00e9terminer autant de d\u00e9cimales de \\(e\\) que l'on d\u00e9sire. Exercice Programmer une fonction factorielle dynamique. Programmer une fonction approx qui en entr\u00e9e prend un entier positif \\(n\\) . renvoie \\(\\sum_{k=0}^{+n}\\frac{1}{k!}\\) en calculant suivant la r\u00e8gle de la photo de classe pour minimiser les erreurs d'arithm\u00e9tique en virgule flottante. Programmer la fonction decimales_de_e qui en entr\u00e9e prend un entier d positif; renvoie l'\u00e9criture d\u00e9cimale de \\(e\\) avec les \\(n\\) premi\u00e8res d\u00e9cimales exactes. Pour la derni\u00e8re question, on pourra utiliser la fonction round : round ( a , 4 ) tronque a \u00e0 la quatri\u00e8me d\u00e9cimale. Remarque : \u00e9crit tel quel, ce programme ne permet pas d'afficher beaucoup de d\u00e9cimales : 17 au maximum. Cela est d\u00fb au format de repr\u00e9sentation des float de Python. Pour en avoir plus, on pourrait s'y prendre autrement... Un programme est une donn\u00e9e comme les autres \u2693\ufe0e C'est d\u00e9j\u00e0 vrai pour les fonctions \u2693\ufe0e Lorsque nous avons \u00e9tudi\u00e9 la programmation fonctionnelle, nous avons expliqu\u00e9 qu'il est possible de passer une fonction en param\u00e8tre \u00e0 une autre fonction. Voici un exemple : def nulle_en_zero ( f ): epsilon = 10 ** - 6 return abs ( f ( 0 )) < epsilon La fonction nulle_en_zero : prend en entr\u00e9e une fonction \\(f\\) (qui est cens\u00e9e \u00eatre une fonction num\u00e9rique d\u00e9finie \u00ab au voisinage de z\u00e9ro \u00bb); renvoie True si \\(f(0)\\) est tr\u00e8s petit et False sinon. Cela reste vrai pour les programmes \u2693\ufe0e De la m\u00eame mani\u00e8re, on peut donner un programme en entr\u00e9e d'un autre programme. D'ailleurs, on le fait plus souvent qu'on ne le croit : Sous Linux / macOS : cat fichier.txt demande au programme cat d'afficher le contenu du fichier fichier.txt Sous Windows / Linux / macOS : python fichier.py donne le fichier fichier.py \u00e0 l' interpr\u00e9teur Python pour que celui-ci l'ex\u00e9cute. Lorsqu'on a \u00e9crit un programme en langage C, tel celui-ci : #include <stdio.h> int main() { printf(\"Hello World!\"); return 0; } et qu'on a sauvegard\u00e9 ce fichier texte sous le nom hello_world.c , alors on utilise un compilateur C qui prend en entr\u00e9e ce fichier et produit (sous Windows) un fichier ex\u00e9cutable hello_world.exe . Quand on compresse un programme, on utilise un autre programme pour le compresser. Quand on utilise un antivirus, il prend (entre autres) des programmes et les analyse. Et c\u00e6tera . Un probl\u00e8me ind\u00e9cidable \u2693\ufe0e C'est Alan Turing qui a prouv\u00e9 le r\u00e9sultat suivant. Il utilisait (\u00e9videmment) des machines de Turing dans sa preuve. Puisque Python est Turing-complet, nous utiliserons Python ! Lorsqu'on programme une fonction, il se peut qu'elle ne s'arr\u00eate pas. C'est souvent tr\u00e8s emb\u00eatant, d'o\u00f9 la question suivante : Existe-t-il une fonction permettant de d\u00e9terminer si une fonction donn\u00e9e s'arr\u00eate o\u00f9 non et ce, quelle que soit cette fonction donn\u00e9e et les param\u00e8tres qu'on lui passe ? Cette question pose ce que l'on appelle le probl\u00e8me de l'arr\u00eat . Supposons qu'une telle fonction existe, appelons-l\u00e0 A : def A ( f , x ) -> bool : \"\"\" Renvoie True si f(x) s'arr\u00eate et False sinon \"\"\" Construisons alors la fonction D suivante : def D ( f ): if A ( f , f ) is True : while True : pass else : return True Que peut-on dire de D(D) ? Si D(D) se termine, alors cela signifie que A(D,D) est faux, donc que D(D) ne se termine pas. Si D(D) ne se termine pas, alors on est entr\u00e9 dans la boucle while , donc A(D,D) est vrai et alors D,(D) se termine. Dans les deux cas on arrive \u00e0 une contradiction. Ainsi notre supposition est erron\u00e9e : La fonction A n'existe pas. Autrement dit il n'existe pas de programme permettant de d\u00e9terminer syst\u00e9matiquement si un programme donn\u00e9 s'arr\u00eate ou non. Le probl\u00e8me de l'arr\u00eat est ind\u00e9cidable . Ce probl\u00e8me est assez abstrait, il existe des probl\u00e8mes plus concrets qui sont pourtants ind\u00e9cidables, tel le probl\u00e8me de correspondance de Post ou le probl\u00e8me de pavage du plan avec un nombre fini de forme polygonales donn\u00e9. Des nombres incalculables ? \u2693\ufe0e Il est facile de montrer que la majorit\u00e9 des nombres r\u00e9els sont incalculables, mais pour autant, il a fallu attendre < date manquante > pour que Gregory Chaitin exhibe un nombre \\(\\Omega\\) non calculable. Sa d\u00e9finition est extr\u00eamement complexe et repose sur les probabilit\u00e9s d'arr\u00eats de certains algorithmes. Peut-on enfoncer le clou encore un peu plus ? \u2693\ufe0e Oui ! En 1931 Kurt G\u00f6del a d\u00e9montr\u00e9 le premier th\u00e9or\u00e8me d'incompl\u00e9tude , riche en implications tant scientifiques que philosophiques. Pour d\u00e9montrer des th\u00e9or\u00e8mes, les math\u00e9maticiens doivent utiliser un syst\u00e8me formel avec des axiomes, et c\u00e6tera . Son th\u00e9or\u00e8me \u00e9nonce que tout syst\u00e8me formel assez puissant pour d\u00e9montrer les th\u00e9or\u00e8mes d'arithm\u00e9tiques (donc en particulier celui que nous utilisons sans vraiment y faire attention) est incomplet : Il existe des propositions pour lesquelles il n'existe ni de preuve qu'elles sont vraies, ni de preuve qu'elles sont fausses. Ce r\u00e9sultat est \u00e0 mettre en parall\u00e8le avec les notions pr\u00e9c\u00e9dentes m\u00eame s'il n'est pas de m\u00eame nature : il d\u00e9pend du syst\u00e8me formel dans lequel on se place, au contraire de la d\u00e9cidabilit\u00e9 et la calculabilit\u00e9...","title":"CH28 : calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"nsi2/ch28/calculabilite.html#calculabilite-et-decidabilite","text":"","title":"Calculabilit\u00e9 et d\u00e9cidabilit\u00e9"},{"location":"nsi2/ch28/calculabilite.html#un-peu-dhistoire-et-des-definitions","text":"","title":"Un peu d'Histoire et des d\u00e9finitions"},{"location":"nsi2/ch28/calculabilite.html#algorithme","text":"Depuis l'Antiquit\u00e9 l'humanit\u00e9 utilise des m\u00e9thodes de calcul pour r\u00e9soudre des probl\u00e8mes, mais jusqu'au d\u00e9but du vingti\u00e8me si\u00e8cle on n'avait aucune d\u00e9finition pr\u00e9cise de ce qu'est une m\u00e9thode de calcul. Pourtant lors du Congr\u00e8s International des Math\u00e9maticiens de Paris de 1900, David Hilbert a formul\u00e9 24 probl\u00e8mes, dont le dixi\u00e8me dont l'\u00e9nonc\u00e9 peut \u00eatre vulgaris\u00e9 en : \u00ab Existe-t-il une m\u00e9thode g\u00e9n\u00e9rale pour d\u00e9terminer quelles \u00e9quations diophantiennes on des solutions et quelles \u00e9quations diophantiennes n'en ont pas ? \u00bb Equations diophantiennes Une \u00e9quation diophantienne est une \u00e9quation \u00e0 une ou plusieurs inconnues; polynomiale : ne figurent que des puissances enti\u00e8res des inconnues; \u00e0 coefficients entiers; dont on cherche des solutions enti\u00e8res. \\(x^2-3x+2 = 0\\) est une \u00e9quation diophantienne de solution 1 et 2. \\(x^2+y^2=z^2\\) en est une autre, ses solutions sont les triplets pythagoriciens. \\(3x^5+2xyz^3+y^2-z+2=0\\) en est une derni\u00e8re... Ce sont les math\u00e9maticiens Church, Kleene, Turing et G\u00f6del qui, entre 1931 et 1936 ont identifi\u00e9 la notion d'algorithme. Chacun d'entre eux s'int\u00e9ressa \u00e0 sa mani\u00e8re et plus ou moins ind\u00e9pendamment des autres \u00e0 une cat\u00e9gorie de fonctions. Ils reconnurent ensuite que ces diff\u00e9rentes classes co\u00efncidaient et appel\u00e8rent cette classe la classe des fonctions calculables . C'est ce qu'on appelle la th\u00e8se de Church : tous les mod\u00e8les de calculs qui ont \u00e9t\u00e9 utilis\u00e9s pour expliquer ce qu'est une fonction calculable sont \u00e9quivalents. Fonction calculable Une fonction est dite calculable s'il existe une fa\u00e7on finie de la d\u00e9crire qui permette effectivement d'en calculer toutes les valeurs. Cette d\u00e9finition fixe \u00e9galement la notion d'algorithme. Ce sont les travaux de Turing qui ont abouti la d\u00e9finition d'algorithme la plus pratique \u00e0 utiliser : en 1936 la notion d'algorithme \u00e9tait acquise. Algorithme Un algorithme est suite finie d'instructions qu'une machine de Turing peut effectuer. Depuis, on s'est employ\u00e9 \u00e0 cr\u00e9er des entit\u00e9s distinctes des machines de Turing, mais qui sont dite Turing-compl\u00e8tes , c'est-\u00e0-dire qui peuvent \u00ab faire tout ce que peut faire une machine de Turing \u00bb Les langages de programmation que nous connaissons (Python, Java, C++ *et c\u00e6tera) sont Turing-complets (ouf !), mais HTML seul (sans CSS) n'est pas Turing-complet.","title":"Algorithme"},{"location":"nsi2/ch28/calculabilite.html#fonction-calculable","text":"Dans le cadre de notre cours on peut donc reformuler : Fonction calculable (deuxi\u00e8me d\u00e9finition) Une fonction est calculable si on peut la programmer (en Python par exemple).","title":"Fonction calculable"},{"location":"nsi2/ch28/calculabilite.html#probleme-decidable","text":"D\u00e8s lors, on peut s'int\u00e9resser \u00e0 la notion de probl\u00e8me d\u00e9cidable . Un probl\u00e8me de d\u00e9cision peut s'envisager ainsi cas g\u00e9n\u00e9ral exemple 1 exemple 2 Nom du probl\u00e8me Primalit\u00e9 d'un entier Probl\u00e8me de l'arr\u00eat Donn\u00e9e : sp\u00e9cification d'une instance du probl\u00e8me un entier naturel un programme (\u00e9crit en Python par exemple) R\u00e9ponse : propri\u00e9t\u00e9 portant sur une instance qui sp\u00e9cifie les instances positives du probl\u00e8me d\u00e9cider si ce nombre est premier d\u00e9cider si ce programme s'arr\u00eate Sans rentrer dans les d\u00e9tails, on peut associer aux probl\u00e8mes de d\u00e9cision des fonctions de d\u00e9cision. Un probl\u00e8me est alors appel\u00e9 d\u00e9cidable si la fonction associ\u00e9e est calculable. Cela nous permet de formuler une d\u00e9finition : Probl\u00e8me d\u00e9cidable Un probl\u00e8me est d\u00e9cidable si on peut \u00e9crire une fonction (en Python ou autre) qui en entr\u00e9e prend les donn\u00e9es du probl\u00e8me renvoie True ou False suivant que les les donn\u00e9es satisfont le probl\u00e8me ou non. Par exemple, le probl\u00e8me \u00ab \\(n\\in\\mathbb{N}\\) est-il premier ? \u00bb est-il d\u00e9cidable : def est_premier ( n : int ) -> bool : for i in range ( 2 , n ): if n % i == 0 : return False return True L'algorithme impl\u00e9ment\u00e9 en Python est fort peu efficace mais l\u00e0 n'est pas le probl\u00e8me : il existe. Donc le probl\u00e8me de la primalit\u00e9 d'un entier positif est d\u00e9cidable. Dire qu'un probl\u00e8me est ind\u00e9cidable signifie donc qu'il n'existe pas d'algorithme permettant de r\u00e9soudre ce probl\u00e8me dans tous les cas (quelles que soient les donn\u00e9es du probl\u00e8me).","title":"Probl\u00e8me d\u00e9cidable"},{"location":"nsi2/ch28/calculabilite.html#nombre-calculable","text":"Tant que nous y sommes, d\u00e9finissons ce qu'est un nombre calculable : Nombre calculable Un nombre r\u00e9el est calculable si et seulement si il existe un algorithme permettant de calculer autant de d\u00e9cimales que l'on veut de l'\u00e9criture en base 10 de ce r\u00e9el. \u00c9videmment si le nombre n'est pas une fraction, son \u00e9criture d\u00e9cimale n'est pas p\u00e9riodique, il est donc hors de question de chercher \u00e0 les conna\u00eetre toutes (sauf cas particulier o\u00f9 l'on a nous m\u00eame fabriqu\u00e9 l'\u00e9criture d\u00e9cimale du nombre). Par exemple, on peut montrer que le nombre \\(e\\) (celui qui permet de construire la fonction exponentielle) vaut \\[\\sum_{k=0}^{+\\infty}\\frac{1}{k!}=\\frac{1}{0!}+\\frac{1}{1!}+\\frac{1}{2!}+\\frac{1}{3!}+\\ldots\\] Avec \\(0!=1\\) , rappelons-le. Il y a une infinit\u00e9 de termes dans la somme (c'est une limite), mais en prenant un nombre suffisant des premiers termes de cette somme, on peut en d\u00e9terminer autant de d\u00e9cimales de \\(e\\) que l'on d\u00e9sire. Exercice Programmer une fonction factorielle dynamique. Programmer une fonction approx qui en entr\u00e9e prend un entier positif \\(n\\) . renvoie \\(\\sum_{k=0}^{+n}\\frac{1}{k!}\\) en calculant suivant la r\u00e8gle de la photo de classe pour minimiser les erreurs d'arithm\u00e9tique en virgule flottante. Programmer la fonction decimales_de_e qui en entr\u00e9e prend un entier d positif; renvoie l'\u00e9criture d\u00e9cimale de \\(e\\) avec les \\(n\\) premi\u00e8res d\u00e9cimales exactes. Pour la derni\u00e8re question, on pourra utiliser la fonction round : round ( a , 4 ) tronque a \u00e0 la quatri\u00e8me d\u00e9cimale. Remarque : \u00e9crit tel quel, ce programme ne permet pas d'afficher beaucoup de d\u00e9cimales : 17 au maximum. Cela est d\u00fb au format de repr\u00e9sentation des float de Python. Pour en avoir plus, on pourrait s'y prendre autrement...","title":"Nombre calculable"},{"location":"nsi2/ch28/calculabilite.html#un-programme-est-une-donnee-comme-les-autres","text":"","title":"Un programme est une donn\u00e9e comme les autres"},{"location":"nsi2/ch28/calculabilite.html#cest-deja-vrai-pour-les-fonctions","text":"Lorsque nous avons \u00e9tudi\u00e9 la programmation fonctionnelle, nous avons expliqu\u00e9 qu'il est possible de passer une fonction en param\u00e8tre \u00e0 une autre fonction. Voici un exemple : def nulle_en_zero ( f ): epsilon = 10 ** - 6 return abs ( f ( 0 )) < epsilon La fonction nulle_en_zero : prend en entr\u00e9e une fonction \\(f\\) (qui est cens\u00e9e \u00eatre une fonction num\u00e9rique d\u00e9finie \u00ab au voisinage de z\u00e9ro \u00bb); renvoie True si \\(f(0)\\) est tr\u00e8s petit et False sinon.","title":"C'est d\u00e9j\u00e0 vrai pour les fonctions"},{"location":"nsi2/ch28/calculabilite.html#cela-reste-vrai-pour-les-programmes","text":"De la m\u00eame mani\u00e8re, on peut donner un programme en entr\u00e9e d'un autre programme. D'ailleurs, on le fait plus souvent qu'on ne le croit : Sous Linux / macOS : cat fichier.txt demande au programme cat d'afficher le contenu du fichier fichier.txt Sous Windows / Linux / macOS : python fichier.py donne le fichier fichier.py \u00e0 l' interpr\u00e9teur Python pour que celui-ci l'ex\u00e9cute. Lorsqu'on a \u00e9crit un programme en langage C, tel celui-ci : #include <stdio.h> int main() { printf(\"Hello World!\"); return 0; } et qu'on a sauvegard\u00e9 ce fichier texte sous le nom hello_world.c , alors on utilise un compilateur C qui prend en entr\u00e9e ce fichier et produit (sous Windows) un fichier ex\u00e9cutable hello_world.exe . Quand on compresse un programme, on utilise un autre programme pour le compresser. Quand on utilise un antivirus, il prend (entre autres) des programmes et les analyse. Et c\u00e6tera .","title":"Cela reste vrai pour les programmes"},{"location":"nsi2/ch28/calculabilite.html#un-probleme-indecidable","text":"C'est Alan Turing qui a prouv\u00e9 le r\u00e9sultat suivant. Il utilisait (\u00e9videmment) des machines de Turing dans sa preuve. Puisque Python est Turing-complet, nous utiliserons Python ! Lorsqu'on programme une fonction, il se peut qu'elle ne s'arr\u00eate pas. C'est souvent tr\u00e8s emb\u00eatant, d'o\u00f9 la question suivante : Existe-t-il une fonction permettant de d\u00e9terminer si une fonction donn\u00e9e s'arr\u00eate o\u00f9 non et ce, quelle que soit cette fonction donn\u00e9e et les param\u00e8tres qu'on lui passe ? Cette question pose ce que l'on appelle le probl\u00e8me de l'arr\u00eat . Supposons qu'une telle fonction existe, appelons-l\u00e0 A : def A ( f , x ) -> bool : \"\"\" Renvoie True si f(x) s'arr\u00eate et False sinon \"\"\" Construisons alors la fonction D suivante : def D ( f ): if A ( f , f ) is True : while True : pass else : return True Que peut-on dire de D(D) ? Si D(D) se termine, alors cela signifie que A(D,D) est faux, donc que D(D) ne se termine pas. Si D(D) ne se termine pas, alors on est entr\u00e9 dans la boucle while , donc A(D,D) est vrai et alors D,(D) se termine. Dans les deux cas on arrive \u00e0 une contradiction. Ainsi notre supposition est erron\u00e9e : La fonction A n'existe pas. Autrement dit il n'existe pas de programme permettant de d\u00e9terminer syst\u00e9matiquement si un programme donn\u00e9 s'arr\u00eate ou non. Le probl\u00e8me de l'arr\u00eat est ind\u00e9cidable . Ce probl\u00e8me est assez abstrait, il existe des probl\u00e8mes plus concrets qui sont pourtants ind\u00e9cidables, tel le probl\u00e8me de correspondance de Post ou le probl\u00e8me de pavage du plan avec un nombre fini de forme polygonales donn\u00e9.","title":"Un probl\u00e8me ind\u00e9cidable"},{"location":"nsi2/ch28/calculabilite.html#des-nombres-incalculables","text":"Il est facile de montrer que la majorit\u00e9 des nombres r\u00e9els sont incalculables, mais pour autant, il a fallu attendre < date manquante > pour que Gregory Chaitin exhibe un nombre \\(\\Omega\\) non calculable. Sa d\u00e9finition est extr\u00eamement complexe et repose sur les probabilit\u00e9s d'arr\u00eats de certains algorithmes.","title":"Des nombres incalculables ?"},{"location":"nsi2/ch28/calculabilite.html#peut-on-enfoncer-le-clou-encore-un-peu-plus","text":"Oui ! En 1931 Kurt G\u00f6del a d\u00e9montr\u00e9 le premier th\u00e9or\u00e8me d'incompl\u00e9tude , riche en implications tant scientifiques que philosophiques. Pour d\u00e9montrer des th\u00e9or\u00e8mes, les math\u00e9maticiens doivent utiliser un syst\u00e8me formel avec des axiomes, et c\u00e6tera . Son th\u00e9or\u00e8me \u00e9nonce que tout syst\u00e8me formel assez puissant pour d\u00e9montrer les th\u00e9or\u00e8mes d'arithm\u00e9tiques (donc en particulier celui que nous utilisons sans vraiment y faire attention) est incomplet : Il existe des propositions pour lesquelles il n'existe ni de preuve qu'elles sont vraies, ni de preuve qu'elles sont fausses. Ce r\u00e9sultat est \u00e0 mettre en parall\u00e8le avec les notions pr\u00e9c\u00e9dentes m\u00eame s'il n'est pas de m\u00eame nature : il d\u00e9pend du syst\u00e8me formel dans lequel on se place, au contraire de la d\u00e9cidabilit\u00e9 et la calculabilit\u00e9...","title":"Peut-on enfoncer le clou encore un peu plus ?"}]}